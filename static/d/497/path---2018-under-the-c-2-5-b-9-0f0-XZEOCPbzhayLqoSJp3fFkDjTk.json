{"data":{"markdownRemark":{"html":"<p>파이썬의 모든 것은 객체다. 당연하게 들릴 수 있으나 객체 지향 언어라고 하려 모든것이 객체인건 아니다.\n예를 들어 자바의 거의 모든것은 객체지만, 원시 자료형 (Primitive Type)은 아니다.\n그러나 파이썬은 숫자도 객체다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token number\">42</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>__add__<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 점을 두개 붙어야 호출 가능하다</span>\n<span class=\"token number\">45.0</span></code></pre></div>\n<p>이와 같은 이유로 객체를 알아보는건 파이썬 내부를 알아보는데 좋은 출발점이다.</p>\n<h1>PyObject</h1>\n<p>파이썬의 객체는 <code class=\"language-text\">PyObject</code>로 이뤄져 있다.\n<code class=\"language-text\">PyObject</code>는 <code class=\"language-text\">Include</code> 폴더의 <code class=\"language-text\">object.h</code>에 다음과 같이\n<a href=\"https://github.com/python/cpython/blob/f320be7/Include/object.h#L106\">정의</a>\n되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> _object <span class=\"token punctuation\">{</span>\n    _PyObject_HEAD_EXTRA\n    Py_ssize_t ob_refcnt<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> _typeobject <span class=\"token operator\">*</span>ob_type<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> PyObject<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이중 <code class=\"language-text\">_PyObject_HEAD_EXTRA</code>매크로는 디버깅에만 사용되므로 무시하자.\n따라서 <code class=\"language-text\">PyObject</code>는 다음의 구조체다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> _object <span class=\"token punctuation\">{</span>\n    Py_ssize_t ob_refcnt<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> _typeobject <span class=\"token operator\">*</span>ob_type<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> PyObject<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">_typeobject</code>는 외부에는 <code class=\"language-text\">PyTypeObject</code>라는 이름으로 사용된다.\n이름처럼 객체에 관한 정보가 기록 된다. <code class=\"language-text\">PyTypeObject</code>의 자세한 소스코드는 <a href=\"https://github.com/python/cpython/blob/f320be7/Include/object.h#L346\">GitHub</a>을 참고하라.\n예를 들어 파이썬 객체의 <code class=\"language-text\">__doc__</code>정보는 <code class=\"language-text\">PyTypeObject</code>의 <code class=\"language-text\">tp_doc</code>필드에 저장된다.</p>\n<p>따라서 필요하다면 C언어로 <code class=\"language-text\">PyTypeObject</code>를 상속받아 새로운 객체를 만들 수도 있다.\n<code class=\"language-text\">PyTypeObject</code>의 내용은 다음에 다루기로 하고, 지금은 다른 필드 <code class=\"language-text\">ob_refcnt</code>를 알아보자.\n변수명에서 눈치 챘겠지만, 레퍼런스 카운팅(이하 RC)을 위한 필드다.</p>\n<h1>Reference Counting</h1>\n<p>파이썬의 주 메모리 관리는 RC로 이뤄진다.\nRC는 객체가 얼마나 사용되는지 레퍼런스 카운트에 기록한다.\n객체가 사용되는 만큼 레퍼런스 카운트를 1씩 증가/감소하며, 레퍼런스 카운트가 0이 되면 메모리에서 해제한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">:</span>\n    name <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__del__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Foo(\"{}\")가 메모리에서 제거 되었습니다'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\na <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># Foo(\"a\")가 새로 생성 되었으므로 레퍼런스 카운트는 1이 된다</span>\nb <span class=\"token operator\">=</span> a  <span class=\"token comment\"># B도 a를 참조 있으므로 Foo의 레퍼런스 카운트는 2가 된다</span>\n\nb <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># B가 더이상 Foo(\"a\")를 사용하지 않으므로 Foo(\"a\")의 레퍼런스 카운트는 1 줄어 들어 1 이 된다</span>\na <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># a도 더이상 Foo(\"a\")를 사용하지 않으므로 Foo(\"a\")의 레퍼런스 카운트는 1 줄어 0이 되어, 해재하며 소멸자를 호출한다</span></code></pre></div>\n<p>파이썬에서 <code class=\"language-text\">__init__</code>는 생성자, <code class=\"language-text\">__del__</code>은 소멸자이다.\n위 코드를  <strong>인터프리터 모드</strong>에서 실행하면 <code class=\"language-text\">a = None</code>을 실행한 직후 <code class=\"language-text\">Foo(&quot;a&quot;)가 메모리에서 제거 되었습니다</code>라는 메시지를 볼 수 있을 것이다.\n이처럼 RC를 사용하면 메모리가 필요 없어진 순간 제거 된다.</p>\n<p>파이썬 내부에선 Reference Count 관리를 위해 <code class=\"language-text\">Py_INCREF</code>와 <code class=\"language-text\">Py_DECREF</code>를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> Py_INCREF(op) (                         \\\n    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \\\n    ((PyObject *)(op))->ob_refcnt++)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> Py_DECREF(op)                                   \\\n    do {                                                \\\n        PyObject *_py_decref_tmp = (PyObject *)(op);    \\\n        if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \\\n        --(_py_decref_tmp)->ob_refcnt != 0)             \\\n            _Py_CHECK_REFCNT(_py_decref_tmp)            \\\n        else                                            \\\n            _Py_Dealloc(_py_decref_tmp);                \\\n    } while (0)</span></code></pre></div>\n<p><code class=\"language-text\">_Py_DEC_REFTOTAL</code>, <code class=\"language-text\">_Py_REF_DEBUG_COMMA</code> 처럼 디버그에서 사용하는 내용을 지우면,\n<code class=\"language-text\">Py_INCREF</code>는 다음과 같으며,</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>PyObject <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>op<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>ob_refcnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">Py_DECREF</code>는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">PyObject <span class=\"token operator\">*</span>_py_decref_tmp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>PyObject <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>op<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">--</span><span class=\"token punctuation\">(</span>_py_decref_tmp<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>ob_refcnt <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">_Py_Dealloc</span><span class=\"token punctuation\">(</span>_py_decref_tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>RC를 사용하면 프로그래머가 큰 신경을 쓰지 않아도, 필요 없다고 판단된 메모리는 그 즉시 해제할 수 있다.\n개인적으로 RC는 <em>비용있는</em> 추상화 방식 중에서는 가장 우아한 방식이라고 생각한다.\n아래의 문제점들만 없다면 말이다.</p>\n<h1>문제</h1>\n<p>메모리관리에 대해 알아본 프로그래머라면 알겠지만, 아쉽게도 RC는 만병통치약이 아니다.</p>\n<h2>오버헤드</h2>\n<p>첫번째로 오버헤드를 이야기 할 수 있다.\n우선 <code class=\"language-text\">PyObject</code>의 <code class=\"language-text\">ob_refcnt</code> 처럼 레퍼런스 카운트를 저장할 공간이 추가적으로 필요하고,\n변수를 할당할때도 추가적으로 레퍼런스 카운트를 관리해야 한다.</p>\n<p><a href=\"https://blog.sn0wle0pard.io/2018/under-the-c-1/\">저번 글</a>에 나온 내용을 다시 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">if</span> A <span class=\"token operator\">!=</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">pass</span></code></pre></div>\n<p>파이썬 인터프리터에게 위 코드는 다음의 C 코드와 비슷하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">PyObject <span class=\"token operator\">*</span>T <span class=\"token operator\">=</span> Py_True<span class=\"token punctuation\">;</span>\n<span class=\"token function\">Py_INCREF</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">PyObject_RichCompareBool</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">,</span> Py_NE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">Py_DECREF</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>변수 <code class=\"language-text\">A</code>와 <code class=\"language-text\">True</code>를 비교하기 위해 임시 변수 <code class=\"language-text\">T</code>를 만들었고, T는 <code class=\"language-text\">Py_True</code>값을 참조 한다.\n아쉽게도 단순히 참조에서 끝나는게 아니라 필요에 따라 <code class=\"language-text\">Py_INCREF</code>와 <code class=\"language-text\">Py_DECREF</code>가 호출 된다.</p>\n<p>오버헤드는 메모리 관리에 드는 수고를 생각하면 넘어갈 수 있을 수도 있다.\n그러나 아쉽게도 해제할 수 없는 메모리도 있다.</p>\n<h2>순환참조</h2>\n<p>RC는 안전하지만 완전하진 않다.\n모든 해제된 메모리는 필요 없는 메모리지만, 모든 필요없는 메모리가 헤제되는건 아니다.</p>\n<p>예를 들어 다음의 코드를 보자,</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">:</span>\n    child <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n    name <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__del__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Foo(\"{}\")가 메모리에서 제거 되었습니다'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\na <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># Foo(\"a\")의 ref count는 1</span>\nb <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># Foo(\"b\")의 ref count는 1</span>\n\na<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> b  <span class=\"token comment\"># a.child가 Foo(\"b\")를 참조하므로 Foo(\"b\")의 레퍼런스 카운트는 1 증가하여 2가 된다</span>\nb<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> a  <span class=\"token comment\"># b.child가 Foo(\"a\")를 참조하므로 Foo(\"a\")의 레퍼런스 카운트는 1 증가하여 2가 된다</span>\n\na <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># a가 더이상 Foo(\"a\")를 참조하지 않으므로 레퍼런스 카운트는 1 감소해서 1 이다</span>\nb <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># b가 더이상 Foo(\"b\")를 참조하지 않으므로 레퍼런스 카운트는 1 감소해서 1 이다</span>\n\n<span class=\"token comment\"># Foo(\"a\")와 Foo(\"b\")모두 접근할 수 없지만, 레퍼런스 카운트가 남아 있으므로 해재되지 않는다</span></code></pre></div>\n<p>위 코드를  <strong>인터프리터 모드</strong>에서 실행하면 <code class=\"language-text\">a = 0</code>이나 <code class=\"language-text\">b = 0</code>이 되면 더이상 <code class=\"language-text\">Foo(&quot;a&quot;)</code>와 <code class=\"language-text\">Foo(&quot;b&quot;)</code>에 접근 할 수 없다.\n그러나 <code class=\"language-text\">a.child</code>와 <code class=\"language-text\">b.child</code>의 참조때문에 올라간 레퍼런스 카운트가 존재해 a와 b가 더이상 child에 접근 못 하더라도 해제가 불가능 하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">:</span>\n    child <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n    name <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__del__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Foo(\"{}\")가 메모리에서 제거 되었습니다'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\na <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># Foo(\"a\")의 ref count는 1</span>\na<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> a  <span class=\"token comment\"># a.child가 Foo(\"a\")를 참조하므로 Foo(\"a\")의 레퍼런스 카운트는 1 증가하여 2가 된다</span>\n\na <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># a가 더이상 Foo(\"a\")를 참조하지 않으므로 레퍼런스 카운트는 1 감소해서 1 이다</span>\n\n<span class=\"token comment\"># Foo(\"a\")에 접근할 수 없지만, 레퍼런스 카운트가 남아 있으므로 해재되지 않는다</span></code></pre></div>\n<p>또 하나, 위처럼 자기 자신을 참조하는 경우도 마찬가지로 해재할 수 없다.\n이 처럼 서로 참조하는 경우를 <strong>순환참조</strong>라고 하며, 레퍼런스 카운트로는 해결하기 까다롭다.</p>\n<p>좀 더 쉬운 예를 하나 보면,</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">x <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\nx<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span></code></pre></div>\n<p>파이썬의 경우 위의 코드는 자기자신을 참조한다.</p>\n<h1>GC</h1>\n<p>이러한 이유로 파이썬은 RC만을 사용하지 않고, 추가적으로 GC도 사용한다.\n엄밀하게 말하면 RC도 GC의 일부지만 이 글에선 RC가 아닌 GC를 말하기로 하자.\n파이썬의 GC는 <code class=\"language-text\">gcmodule.c</code>에 <a href=\"https://github.com/python/cpython/blob/master/Modules/gcmodule.c\">정의</a> 되어 있으며,\n자세한 내용은 추후에 다루도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">:</span>\n    child <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n    name <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__del__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Foo(\"{}\")가 메모리에서 제거 되었습니다'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\na <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># a의 ref count는 1</span>\nb <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># b의 ref count는 1</span>\n\nb<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> a  <span class=\"token comment\"># a의 ref count는 2</span>\na<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> b  <span class=\"token comment\"># b의 ref count는 2</span>\n\na <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># a의 ref count는 1 감소해서 1 이다 (b.child에 참조가 남아있다)</span>\nb <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># b의 ref count는 1 감소해서 1 이다 (a.child에 참조가 남아있다)</span>\n\n<span class=\"token keyword\">import</span> gc\ngc<span class=\"token punctuation\">.</span>collect<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># GC를 직접 호출해보자 (원래는 필요한 경우 자동으로 호출 된다)</span></code></pre></div>\n<p>위의 코드를 실행하면 <code class=\"language-text\">gc.collect()</code>가 더이상 접근할 수 없는 객체를 해재하는 것을 볼 수 있다.\n특별한 설정을 하지 않는다면 파이썬은 자동으로 필요할때 gc를 호출해 RC로 해재할 수 없는 객체를 해제해 준다.</p>\n<p>GC도 사용하므로 파이썬의 메모리 관리는 아쉽게도 RC하나만 사용하는 것에 비해 추가적인 비용이 든다.</p>\n<p>다행인 점은 파이썬의 GC는 순환참조를 만들 가능성이 있는 컨테이너 객체를 대상으로 사용되어 모든 객체를 검사하진 않는다.</p>\n<p>실제로, GC는 파이썬 2.0 버전부터 도입 되었으며 <a href=\"http://www.arctrix.com/nas/python/gc/\">당시 자료</a>를 보면 이전 버전에 비해 약 4%의 성능 저하의 원인으로 생각한다고 한다.</p>\n<p>이런 이유로 성능에 여유가 없거나, 순환참조를 피할 자신이 있다면 <code class=\"language-text\">gc.disable()</code>로 GC를 꺼도 된다.\n대표적으로 <a href=\"https://instagram-engineering.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172\">인스타그램</a>은 GC를 사용하지 않는다고 한다.</p>\n<h2>덤: 약한참조</h2>\n<p>다른 RC를 사용하는 언어를 사용한 분들은 들어본적이 있겠지만,\n순환참조로 인한 메모리 누수를 피하는 또다른 방법은 <strong>약한참조</strong>가 있다.</p>\n<p>쉽게 설명하면 참조는 하되, 레퍼런스 카운트는 올리지 않는 것이다.\n파이썬은 <code class=\"language-text\">weakref</code>모듈을 통해 약한 참조를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">:</span>\n    child <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n    name <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__del__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Foo(\"{}\")가 메모리에서 제거 되었습니다'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\na <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># a의 ref count는 1</span>\nb <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># b의 ref count는 1</span>\n\n<span class=\"token keyword\">import</span> weakref\n\n<span class=\"token comment\"># weakref를 사용했으므로 레퍼런스 카운트는 변화하지 않는다</span>\na<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> weakref<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># Foo(\"b\")의 레퍼런스 카운트는 여전히 1 이다</span>\nb<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> weakref<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># Foo(\"a\")의 레퍼런스 카운트는 여전히 1 이다</span>\n\n<span class=\"token comment\"># 그러나 접근은 가능하다</span>\n<span class=\"token comment\"># child 자체는 weakref 객체이므로 호출을 통해 가리키는 객체를 가져올수 있다</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n\na <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># Foo(\"a\")의 레퍼런스 카운트는 1 감소해서 0 이다</span>\n<span class=\"token comment\"># 소멸자가 호출된다</span>\n\n<span class=\"token comment\"># 더이상 접근이 불가능하므로 None이 반환된다</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\nb <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># Foo(\"b\")의 레퍼런스카운트는 1 감소해서 0 이다</span>\n<span class=\"token comment\"># 소멸자가 호출된다</span></code></pre></div>\n<p><code class=\"language-text\">weakref</code>는 접근이 가능하면 해당 객체를, 해당객체가 접근 불가능 하면 <code class=\"language-text\">None</code>을 반환한다.</p>\n<h1>RC와 GIL</h1>\n<p>CPython은 멀티 <em>스레드</em>를 효율적으로 사용하지 못한다.\n한 파이썬 프로세스는 한번에 한 스레드만 사용하며, 이를 GIL (Global interpreter lock) 이라고 부른다.</p>\n<p>CPython에서 GIL을 제거하려는 시도는 종종 있지만, 아직까지는 GIL이 남아 있다.\n그 이유중 하나가 바로 RC 때문이다.</p>\n<p>다만 GIL 자체는 선택사항이며 원한다면 RC를 쓰고도 GIL을 제거 할 수도 있다.\n잠시 다른 파이썬 구현체를 보자.</p>\n<ul>\n<li>Jython은 GC로 관리 하며, GIL이 없다</li>\n<li>IronPython은 GC로 메모리 관리 하며, GIL이 없다</li>\n<li>PyPy는 GC로 메모리 관리를 하며, GIL이 <em>있다</em></li>\n</ul>\n<p>PyPy가 대표적으로 GC만 사용하나, GIL이 존재한다.\n그러나, PyPy는 2017년 8월 블로그글 <a href=\"https://morepypy.blogspot.kr/2017/08/lets-remove-global-interpreter-lock.html\">Let's remove the Global Interpreter Lock</a>를 통해 GIL을 제거할 수 있음을 알렸다.</p>\n<p>PyPy의 블로그 글에 따르면 CPython에서 GIL을 제거하기 힘든 두가지 이유는 다음과 같다.</p>\n<ul>\n<li>how do we guard access to mutable data structures with locks and</li>\n<li>what to do with reference counting that needs to be guarded.</li>\n</ul>\n<p>멀티스레드에서 발생하는 문제중 하나는 여러 스레드가 동시에 한 변수를 수정하려는 문제이다.\n멀티스레드를 사용해본 경험이 있다면 <code class=\"language-text\">lock guard</code>와 <code class=\"language-text\">mutex</code>등을 보거나 사용해본 점이 있을 것이다.</p>\n<p>그렇다면 스레드간 공유하는 객체는 읽기만 가능하고, 수정은 못하게 한다면 되지 않을까?\n좋은 접근이지만 RC를 사용하면 쉽지많은 않은 일이다.</p>\n<p>다시 위의 코드를 보자</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">pass</span>\n\na <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>getrefcount<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">read_foo</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>getrefcount<span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span>\n\nread_foo<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># read_foo의 매개변수 foo가 a를 참조 있으므로 Foo의 레퍼런스 카운트는 증가하였다</span>\n<span class=\"token comment\"># read_a 함수가 끝나면 레퍼런스 카운트는 다시 줄어든다</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>getrefcount<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">getrefcount</code>는 객체의 레퍼런스 카운트 갯수를 구하는 함수다.\n우리가 생각한 레퍼런스 카운트 횟수보다 좀 더 많을 텐데 <a href=\"https://docs.python.org/3/library/sys.html#sys.getrefcount\">문서</a>의 내용에 따르면, <code class=\"language-text\">getrefcount</code>함수를 실행하기 위해 매개변수로 참조 카운트가 증가 하여 그렇다.</p>\n<p>내용으로 돌아가면 <code class=\"language-text\">read_foo</code>는 <code class=\"language-text\">a</code>의 내용을 읽기만 하고 수정하진 않았지만, 매개변수등 참조가 일어 날때마나 <code class=\"language-text\">obj_refcnt</code>는 증/감 한다.\n여러 스레드가 동시에 참조를 만든다면 동시수정과 다름 없는 상태가 된다.</p>\n<p>추가로 RC를 사용하고도 이 문제를 피할 방법 자체는 있다.\n예를 들어 <code class=\"language-text\">std::atomic</code>이 있다(<a href=\"http://www.cplusplus.com/reference/atomic/atomic/\">C++ 문서</a>).\natomic은 DB의 Atomic 성질 처럼 순서대로 진행하는걸 보장하는데,\n즉 두 스레드가 거의 동시에 레퍼런스 카운트를 변화 하려고 하면, 먼저 요청한 스레드의 요청대로 한 obj_refcnt를 변화시키고, 그 다음 스레드 요청을 처리한다.</p>\n<p>대표적인 예로 Rust의 <code class=\"language-text\">Rc</code>와 <code class=\"language-text\">ARc</code>가 있다.\nRust 자체는 무비용 추상화로 메모리를 관리하지만, 원한다면 RC로 관리되는 객체를 만들 수 있다.\n이 경우 싱글 스레드면 <code class=\"language-text\">Rc</code>를 멀티 스레드면 <code class=\"language-text\">ARc</code>를 사용하면 되는데, <code class=\"language-text\">ARc</code>는 레퍼런스 카운트가 atomic 하게 동작한다.</p>\n<p>Atomic을 보장하는 것은 추가적인 오버헤드가 있다는 이야기다.\n실제로 ARc <a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html\">문서</a>를 보면,\n원자성 보장은 일반 메모리 접근보다 비용이 많이 들고, 싱글스레드라면 비용을 줄이기 위에 <code class=\"language-text\">Rc</code>를 쓸 수 있다고 언급하고 있다.</p>\n<p>현재 파이썬의 대부분은 싱글 스레드 환경이며, 멀티스레드를 위해 싱글스레드 저하를 선택할 것인가는 논쟁의 여지가 있다.\n현재로는 파이썬 커뮤니티는 멀티스레드 사용을 위해 싱글스레드 성능이 저하 되는 해결을 받아 들이고 싶어 하지 않는다.\n<a href=\"https://wiki.python.org/moin/GlobalInterpreterLock?action=show&#x26;redirect=GIL\">파이썬 위키</a>의 GIL 항목을 인용 하면</p>\n<blockquote>\n<p>The BDFL has said he will reject any proposal in this direction that slows down single-threaded programs.</p>\n</blockquote>\n<p>BDFL은 파이썬 창시자 귀도 반 로썸을 말한다. 위키백과의 설명을 인용한다.</p>\n<blockquote>\n<p>자비로운 종신독재자(BDFL, Benevolent Dictator for Life)란 소수의 오픈 소스 소프트웨어 개발 리더에게 부여되는 칭호이다. 주로 커뮤니티 내에서 논쟁이 있을 때 최종적으로 결론을 내려줄 수 있는, 프로젝트 창시자인 경우가 많다. 이 표현은 1995년에 파이썬의 창시자 귀도 반 로섬을 가리키는 호칭으로 처음 사용되었다.</p>\n</blockquote>\n<p>개인적으로도 멀티스레드를 위해 싱글스레드 성능저하가 심각하다면 받아 들이고 싶지 않다.</p>\n<p>실제로 파이썬에 atomic 레퍼런스 카운트를 사용하게되면 <a href=\"https://greek0.net/blog/2015/05/23/python_atomic_refcounting_slowdown/\">약 23%의 성능저하</a>를 보인다고 한다.</p>\n<p>공유하는 객체만 원자성 보장을 하면 어떨까?\n멀티 스레드를 사용하는 코딩을 해도 스레드간 공유될 객체가 몇 안될 것 같다고 생각한다면,\n파이썬 콘솔을 켜서 다음 코드를 실행해 보길 권한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token keyword\">import</span> sys\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> sys<span class=\"token punctuation\">.</span>getrefcount<span class=\"token punctuation\">(</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">2296</span></code></pre></div>\n<p>글을 시작하며 언급한것 처럼 파이썬의 모든건 객체다.\n단순한 값으로 생각할 수 있는 <code class=\"language-text\">None</code>도 하나의 객체며 여러곳에서 공유하고 있다.\n왜 어려운 문제인지 짐작 할 수 있을 것이다.</p>","excerpt":"파이썬의 모든 것은 객체다. 당연하게 들릴 수 있으나 객체 지향 언어라고 하려 모든것이 객체인건 아니다.\n예를 들어 자바의 거의 모든것은 객체지만, 원시 자료형 (Primitive Type…","fields":{"slug":"/2018/under-the-c-2/"},"frontmatter":{"title":"Under the C: PyObject","date":"2018-04-21"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2018/under-the-c-2/"}}