<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.20.0"/><meta property="og:type" content="article" data-gatsby-head="true"/><meta property="og:title" content="Node.js와 Rust의 우아한 결합 napi-rs" data-gatsby-head="true"/><meta property="og:description" content="어쩌면 가장 멋진 만남" data-gatsby-head="true"/><meta property="og:image" content="/static/cde027f2263994b6dd5d65944c3d9e28/a145d/thumbnail.png" data-gatsby-head="true"/><meta property="og:author" content="이한" data-gatsby-head="true"/><meta property="og:site_name" content="명시지(明示知) - 기록할 수 있는 지식을 나눕니다" data-gatsby-head="true"/><meta name="msapplication-TileColor" content="#000000" data-gatsby-head="true"/><meta name="theme-color" content="#000000" data-gatsby-head="true"/><meta property="article:author" content="이한" data-gatsby-head="true"/><meta name="twitter:card" content="summary" data-gatsby-head="true"/><meta name="twitter:creator" content="@hanleedev" data-gatsby-head="true"/><meta name="twitter:image" content="/static/cde027f2263994b6dd5d65944c3d9e28/a145d/thumbnail.png" data-gatsby-head="true"/><meta name="twitter:label1" content="읽는 시간" data-gatsby-head="true"/><meta name="twitter:data1" content="4분" data-gatsby-head="true"/><style data-href="/styles.618336a6b0dc03f16839.css" data-identity="gatsby-global-css">@font-face{font-display:swap;font-family:Pretendard;font-weight:900;src:local("Pretendard Black"),url(/static/Pretendard-Black-14a71ec59ff2b3bc6933d54c6ee04ff1.woff2) format("woff2"),url(/static/Pretendard-Black-fe80bd8c7ce9b3af972f6e99a5646522.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:800;src:local("Pretendard ExtraBold"),url(/static/Pretendard-ExtraBold-55bef92e8f01b6b6ef2f8d31fdc0f951.woff2) format("woff2"),url(/static/Pretendard-ExtraBold-82ea4400a5eea299b40c94aac01985ba.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:700;src:local("Pretendard Bold"),url(/static/Pretendard-Bold-0676c8838a37a3b770d85a5534f5fdcb.woff2) format("woff2"),url(/static/Pretendard-Bold-f6866c5eb21ccb9a8749d3a2874a7e6e.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:600;src:local("Pretendard SemiBold"),url(/static/Pretendard-SemiBold-7e5eaaf650b9e738991373a7f173b94a.woff2) format("woff2"),url(/static/Pretendard-SemiBold-a0c72d6162af72df37ec279440595738.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:500;src:local("Pretendard Medium"),url(/static/Pretendard-Medium-ea235f1edb8815831a25b376b479949e.woff2) format("woff2"),url(/static/Pretendard-Medium-f902522b86842449110e07cbc07b8346.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:400;src:local("Pretendard Regular"),url(/static/Pretendard-Regular-6090e6b5524796768e78f23519d16488.woff2) format("woff2"),url(/static/Pretendard-Regular-ab56c53f21ca6b32d15fe0ae8daf5f60.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:300;src:local("Pretendard Light"),url(/static/Pretendard-Light-27c9a07cbc308ce88d1ab3613e3152c7.woff2) format("woff2"),url(/static/Pretendard-Light-40808ea4485a78c05f9213ed583b0046.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:200;src:local("Pretendard ExtraLight"),url(/static/Pretendard-ExtraLight-1a26bede4e9bc7d2e9c0ce548cd4cf83.woff2) format("woff2"),url(/static/Pretendard-ExtraLight-ff5e73a97b5e7a5c5d5fed684594e8ad.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:100;src:local("Pretendard Thin"),url(/static/Pretendard-Thin-41861ab4e67767c4c6ed0b5e361fbca6.woff2) format("woff2"),url(/static/Pretendard-Thin-348f24715998d74e9f5529afd376f55b.woff) format("woff")}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#000;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;-o-tab-size:4;tab-size:4;text-align:left;text-shadow:0 1px #fff;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#b3d4fc;text-shadow:none}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{background:hsla(0,0%,100%,.5);color:#9a6e3a}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><title data-gatsby-head="true">Node.js와 Rust의 우아한 결합 napi-rs | </title><link rel="alternate" type="application/rss+xml" title="명시지(明示知) - 기록할 수 있는 지식을 나눕니다" href="/rss.xml" data-gatsby-head="true"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png" data-gatsby-head="true"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png" data-gatsby-head="true"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png" data-gatsby-head="true"/><link rel="manifest" href="/favicon/site.webmanifest" data-gatsby-head="true"/><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="alternate" type="application/rss+xml" title="명시지 (明示知)" href="/rss.xml"/><link rel="preconnect" href="https://www.google-analytics.com"/><link rel="dns-prefetch" href="https://www.google-analytics.com"/><style id="stitches">--sxs{--sxs:0 t-gdxNDc}@media{:root,.t-gdxNDc{--colors-gray000:#F8F9FA;--colors-gray100:#F1F3F5;--colors-gray200:#E9ECEF;--colors-gray300:#DEE2E6;--colors-gray400:#CED4DA;--colors-gray500:#ADB5BD;--colors-gray600:#868E96;--colors-gray700:#495057;--colors-gray800:#343A40;--colors-gray900:#212529;--colors-blue700:#1C7ED6}}--sxs{--sxs:1 hKePEu}@media{body{padding:0;margin:0;font-size:16px;color:var(--colors-gray800);font-weight:400;font-family:Pretendard,sans-serif}*{box-sizing:border-box}}--sxs{--sxs:2 c-bSvfqS c-hEdiuM c-drslhw c-gGqMDa c-jEDjTQ c-dvRuTq c-bZcNek c-jwOSHF c-dMmbPO c-euCchw c-boZbfK c-gBKazA c-eXJruw c-fzsocY c-eJVyyl c-fXXVzC c-hdzxtM c-dpWDmP c-bxCTAm c-jDcCnV c-bvNJHJ c-bHVmPA}@media{.c-bSvfqS{max-width:1000px;padding:24px;margin:0 auto}.c-hEdiuM{width:36px;height:36px}.c-drslhw{font-size:18px;line-height:1.8;word-break:keep-all}.c-drslhw h1,.c-drslhw h2,.c-drslhw h3,.c-drslhw p{margin-top:0;margin-bottom:12px}.c-drslhw h1,.c-drslhw h2,.c-drslhw h3{font-weight:600}.c-drslhw h1{font-size:1.5rem}.c-drslhw h2{font-size:1.25rem}.c-drslhw h3{font-size:1.15rem}.c-drslhw p code{font-size:16px;line-hight:16;padding:1px 4px;border-radius:4px;margin-right:2px;background-color:var(--colors-gray000);border:1px solid var(--colors-gray200)}.c-drslhw a{color:var(--colors-blue700);text-decoration:none}.c-drslhw blockquote{margin:12px 0;padding:1px 16px;color:var(--colors-gray600);border-left:5px solid var(--colors-gray200)}.c-drslhw blockquote p{margin:4px 0}.c-drslhw iframe{display:block;max-width:100%;margin:0 auto;margin-bottom:18px}.c-drslhw pre[class*="language-"]{font-size:16px;border-radius:8px;border:1px solid var(--colors-gray200);background-color:var(--colors-gray000)}.c-drslhw pre[class*="language-"] .token.operator{background-color:transparent}.c-drslhw pre[class*="language-"] .gatsby-highlight-code-line{display:block;background-color:var(--colors-gray200);margin-left:-16px;margin-right:-16px;padding-left:16px}.c-drslhw .footnotes hr{border-top:none;border-color:var(--colors-gray200)}.c-gGqMDa{font-size:2rem;font-weight:600;margin-bottom:0 !important}.c-jEDjTQ{display:flex;align-items:center;margin-top:24px;background-color:var(--colors-gray000);border-radius:16px;padding:16px}.c-dvRuTq{width:72px;height:72px;border-radius:50%}.c-bZcNek{flex:1;margin-left:24px}.c-jwOSHF{margin:0;font-size:1.25rem;color:var(--colors-gray700);font-weight:600}.c-dMmbPO{margin:6px 0;font-weight:400;color:var(--colors-gray600)}.c-euCchw{font-size:0.85rem;color:var(--colors-gray600);margin-right:8px}.c-boZbfK{max-width:1000px;padding:100px 24px;margin:0 auto}@media screen and (max-width: 1000px){.c-boZbfK{padding:60px 24px}}.c-gBKazA{margin-bottom:24px}.c-eXJruw{color:var(--colors-gray700);font-size:1.75rem;font-weight:600;margin:0}.c-fzsocY{color:var(--colors-gray500);font-size:1.25rem}.c-eJVyyl{margin:0;margin-top:6px;color:var(--colors-gray600);font-weight:300;font-size:1rem}.c-fXXVzC{margin:0;padding:0}.c-hdzxtM{list-style:none;border-bottom:1px solid var(--colors-gray100)}.c-hdzxtM:last-child{border:none}.c-jDcCnV{font-size:1.25rem;color:var(--colors-gray700);font-weight:600;margin:0}.c-bvNJHJ{margin:0;margin-top:6px;color:var(--colors-gray600);font-weight:400}.c-bxCTAm{padding:16px;word-break:keep-all}.c-bxCTAm:hover{border-radius:12px;background-color:var(--colors-gray000)}.c-dpWDmP{display:block;text-decoration:none}.c-bHVmPA{width:100%;border-radius:16px}}</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><main class="c-bSvfqS"><header><a href="/"><img src="/images/logo.png" draggable="false" alt="블로그 로고" width="36" height="36" class="c-hEdiuM"/></a></header><article class="c-drslhw"><h1 class="c-gGqMDa">Node.js와 Rust의 우아한 결합 napi-rs</h1><p>2022-08-16</p><p><a href="https://github.com/napi-rs/napi-rs" target="_blank" rel="noopener noreferrer">napi-rs</a>는 Node API를 이용해 러스트로 작성된 코드를 노드에서 사용할 수 있도록 해주는 멋진 라이브러리 입니다.</p><h1>노드 애드온</h1><p>노드에서 네이티브 확장 기능은 <a href="https://nodejs.org/api/addons.html" target="_blank" rel="noopener noreferrer">노드 애드온</a>이라고 합니다.
노드 애드온은 <code>.node</code> 확장자를 가진 동적 라이브러리 입니다. 윈도우에서는 dll, 맥에서는 dylib, 리눅스에서는 so와 동일합니다.</p><p>노드의 <code>require</code> 함수는 <code>.node</code>확장자를 만나면 동적 라이브러리로 판단하고 초기화 합니다. 개발자는 노드와 상호작용할 수 있는 코드를 만들고 이를 <code>.node</code>확장자를 가진 동적 라이브러리로 만들면 네이티브 기능을 노드와 연동할 수 있습니다.</p><h1>노드 애드온의 간단한 역사</h1><p>노드의 애드온 개발은 험난한 역사를 가지고 있어 노드와 상호작용 하는 방법이 여러가지가 있습니다. 왜 Node API가 나왔고, 우리는 Node API를 사용해야 하는지 알아봅시다.</p><h2>V8</h2><p>초기 노드 애드온은 V8의 헤더를 직접 사용하여 작성되었습니다.
그런데 V8의 API는 V8에 버전에 따라서 너무나 빠르고 다양하게 변경되었습니다. 이런 이유로 노드 애드온을 유지 보수하는 일은 쉬운일이 아니었습니다.</p><h2>NAN</h2><blockquote><p>아래의 코드는 <a href="https://napi.rs/docs/deep-dive/history" target="_blank" rel="noopener noreferrer">napi-rs</a> 문서에서 가져왔습니다.</p></blockquote><p>위와 같은 문제를 해결하기 위해 노드 0.8버전부터 <a href="https://github.com/nodejs/nan" target="_blank" rel="noopener noreferrer">NAN</a>이 만들어졌습니다. NAN은 Native Abstractions for Node.js의 약자로, V8 API를 추상화하여 서로 다른 V8엔진이더라도 <strong>코드의 수정없이</strong> 사용할 수 있도록 제공하였습니다.</p><p>NAN은 C++의 매크로와 템플릿을 이용하여 컴파일에 서로 다른 코드로 변경 합니다.</p><p>예를들어 아래의 코드는</p><div class="gatsby-highlight" data-language="cpp"><pre class="language-cpp"><code class="language-cpp"><span class="token function">NAN_METHOD</span><span class="token punctuation">(</span>Echo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span></code></pre></div><p>버전에 따라 컴파일 타임에 서로 다른 코드로 변경되었습니다.</p><div class="gatsby-highlight" data-language="cpp"><pre class="language-cpp"><code class="language-cpp">Handle<span class="token operator">&lt;</span>Value<span class="token operator">&gt;</span> <span class="token function">Echo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Arguments<span class="token operator">&amp;</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 0.10.x</span>
<span class="token keyword">void</span> <span class="token function">Echo</span><span class="token punctuation">(</span>FunctionCallbackInfo<span class="token operator">&lt;</span>Value<span class="token operator">&gt;</span><span class="token operator">&amp;</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6.x</span></code></pre></div><p>이렇게 NAN을 이용하면 버전별로 <strong>다른 코드</strong>를 자동으로 만들어, V8 의 API가 변해도 NAN의 버전만 올리면 코드의 수정없이 새로운 V8엔진에 대응할 수 있었습니다.
NAN은 널리 사용되었으며, 지금도 노드의 네이티브 지원에 대해 검색해보면 많은 튜토리얼이 노출되고 있습니다.</p><p>그런데 NAN도 문제가 있습니다. 코드는 호환되지만, 컴파일한 결과물은 서로 다릅니다. V8의 버전이 달라지면 이전 버전에서 컴파일한 노드 애드온은 새 버전에서 작동하지 않습니다. 새 버전에서 작동하려면 다시 컴파일을 해야했습니다.
<strong>즉, 서로 다른 노드 버전간 코드는 호환되지만 결과물은 호환되지 않습니다.</strong></p><p>이와 같은 이유로 노드 8버전 이전에 node-sass 같은 라이브러리를 사용했다면, 노드의 버전이 올라갔을때 새로운 버전을 받거나, <code>npm rebuild</code> 명령어로 라이브러리를 다시 빌드해야지만 사용할 수 있었습니다.</p><h2>Node API (N-API)</h2><p>이런 문제를 해결하기 위해 <a href="https://nodejs.org/api/n-api.html" target="_blank" rel="noopener noreferrer">N-API</a>가 탄생하였습니다. N-API는 노드 버전 8부터 도입되었으며, 현재는 Node API로 이름이 변경 되었습니다. (이와 같은 이유로 Node API보다는 N-API로 검색하면 더 다양한 자료를 찾을 수 있습니다.)</p><p>Node API의 가장 큰 특징은 NAN과 다르게 <a href="https://ko.wikipedia.org/wiki/%EC%9D%91%EC%9A%A9_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%9D%B4%EC%A7%84_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4" target="_blank" rel="noopener noreferrer">ABI</a> 호환성을 가진다는 점입니다. Node API로 작성된 노드 애드온은 재 컴파일을 하지 않아도, 서로 다른 버전의 노드에서 문제 없이 사용할 수 있습니다.</p><p>Node API가 가지는 또 다른 장점은, V8의 API들과 독립적인 점 입니다.</p><p>V8은 C++로 작성되어 있어, 여러 C++ 클래스를 직접 사용해야하여 NAN은 C++를 사용해야했습니다. Node API는 C로 개발할 수 있도록 작성되었으며, 덕분에 다양한 언어에서 호환성이 높아졌습니다. (일반적으로 C언어에 호환되는 FFI를 만드는것이 더 쉽습니다.)</p><p>또다른 장점은 다른 JS 엔진을 사용해도 네이티브 기능을 사용하는 라이브러리를 호환 시킬 수 있습니다.
실제로 최근 주목받았던 새로운 JS런타임 <a href="https://github.com/oven-sh/bun" target="_blank" rel="noopener noreferrer">bun</a>은 자바스크립트 엔진으로 WebKit의 JavaScriptCore를 사용하지만 <a href="https://github.com/oven-sh/bun#node-api-napi" target="_blank" rel="noopener noreferrer">Node API를 구현하여</a> 노드 애드온도 호환 됩니다.</p><p>이런 이유로 현 시점에서 노드의 네이티브 확장을 위해서는 Node API를 사용하는것이 가장 좋습니다.</p><p>그렇다면 napi-rs는 어떻게 러스트와 Node API를 이어줄까요?</p><h1>우아한 API</h1><blockquote><p>이 문단의 많은 코드는 napi-rs 문서에서 가져왔습니다.</p></blockquote><p>napi-rs의 API는 러스트와 노드를 한 몸처럼 이어 줍니다. 예를 들어 두 숫자를 더하는 러스트 함수를 노드에서 사용하도록 만들어봅시다. 우선 러스트 함수는 아래와 같을 겁니다.</p><div class="gatsby-highlight" data-language="rust"><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">add_numbers</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> m<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n <span class="token operator">+</span> m<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p>이제 napi-rs를 사용해 노드에서 사용할 수 있게 바꿔봅니다.</p><div class="gatsby-highlight has-highlighted-lines" data-language="rust"><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">napi<span class="token punctuation">::</span>bindgen_prelude<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line"><span class="token attribute attr-name">#[napi]</span></span><span class="token keyword">fn</span> <span class="token function-definition function">add_numbers</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> m<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n <span class="token operator">+</span> m<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p><code>#[napi]</code> 매크로만 추가한다면 아주 간단히 노드에서 사용할 수 있는 코드로 변경됩니다!</p><p>위 코드는 노드에서 아래 처럼 사용할 수 있습니다.</p><div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> addNumbers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#x27;./output.node&#x27;</span>

<span class="token comment">// out: 3</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">addNumbers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div><p>특별한 지정이 없다면 napi-rs는 함수이름을 camelCase로 변경해줍니다.</p><p>참고로 JS의 여러 기본함수가 camelCase로 작성된것과 달리 러스트는 함수이름을 snake_case로 짓는것을 권장합니다. napi-rs를 이용하면 두 언어에서 널리 사용되는 컨벤션을 지키면서 코딩할 수 있게 해줍니다.</p><p>napi-rs는 더 멋진일도 도와줍니다. 우선, napi-rs는 struct를 class로 사용할 수 있게 바꿔줍니다.</p><div class="gatsby-highlight" data-language="rust"><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">napi<span class="token punctuation">::</span>bindgen_prelude<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="token attribute attr-name">#[napi(js_name = <span class="token string">&quot;QueryEngine&quot;</span>)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">QueryEngine</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token attribute attr-name">#[napi(js_name = <span class="token string">&quot;QueryEngine&quot;</span>)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">JsQueryEngine</span> <span class="token punctuation">{</span>
  engine<span class="token punctuation">:</span> <span class="token class-name">QueryEngine</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token attribute attr-name">#[napi]</span>
<span class="token keyword">impl</span> <span class="token class-name">JsQueryEngine</span> <span class="token punctuation">{</span>
  <span class="token attribute attr-name">#[napi(factory)]</span>
  <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">with_initial_count</span><span class="token punctuation">(</span>count<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
    <span class="token class-name">JsQueryEngine</span> <span class="token punctuation">{</span> engine<span class="token punctuation">:</span> <span class="token class-name">QueryEngine</span><span class="token punctuation">::</span><span class="token function">with_initial_count</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token attribute attr-name">#[napi(constructor)]</span>
  <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
    <span class="token class-name">JsQueryEngine</span> <span class="token punctuation">{</span> engine<span class="token punctuation">:</span> <span class="token class-name">QueryEngine</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/// Class method</span>
  <span class="token attribute attr-name">#[napi]</span>
  <span class="token keyword">pub</span> <span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">query</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> query<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token namespace">napi<span class="token punctuation">::</span></span><span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>engine<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span>
  <span class="token punctuation">}</span>

  <span class="token attribute attr-name">#[napi(getter)]</span>
  <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">status</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token namespace">napi<span class="token punctuation">::</span></span><span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token keyword">u32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>engine<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token attribute attr-name">#[napi(setter)]</span>
  <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> count<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>engine<span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div><p>노드에선 아래같은 코드처럼 사용 할 수 있습니다.</p><div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">QueryEngine</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">withInitialCount</span><span class="token punctuation">(</span>count<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> QueryEngine
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">query</span><span class="token punctuation">(</span>query<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span>
  <span class="token keyword">get</span> <span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span>
  <span class="token keyword">set</span> <span class="token function">count</span><span class="token punctuation">(</span>count<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div><p>러스트도 자바스크립트처럼 <code>async-await</code> 함수를 지원하는데요, napi-rs는 <code>async</code>함수를 노드에서 사용할 수 있게 바꿀 수 있습니다.</p><div class="gatsby-highlight" data-language="rust"><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">futures<span class="token punctuation">::</span>prelude<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">napi<span class="token punctuation">::</span>bindgen_prelude<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="token attribute attr-name">#[napi]</span>
<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">read_file_async</span><span class="token punctuation">(</span>path<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">Buffer</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div><p>심지어 노드의 <code>Promise</code>를 러스트 코드에서 <code>await</code>할 수 있도록 지원해주기 까지 합니다.</p><div class="gatsby-highlight" data-language="rust"><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">napi<span class="token punctuation">::</span>bindgen_prelude<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="token attribute attr-name">#[napi]</span>
<span class="token keyword">pub</span> <span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">async_plus_100</span><span class="token punctuation">(</span>p<span class="token punctuation">:</span> <span class="token class-name">Promise</span><span class="token operator">&lt;</span><span class="token keyword">u32</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token keyword">u32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> v <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token keyword">await</span><span class="token operator">?</span><span class="token punctuation">;</span>
  <span class="token class-name">Ok</span><span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> asyncPlus100 <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#x27;./output.node&#x27;</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">asyncPlus100</span><span class="token punctuation">(</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// 120</span></code></pre></div><p>위처럼 napi-rs를 사용하면 <code>#[napi]</code>의 추가만으로 아주 자연스럽게 러스트와 노드를 이어줄 수 있습니다.</p><p>어떻게 이런일이 가능할까요? 이건 러스트의 강력한 매크로 덕분입니다.</p><h2>macro</h2><p>러스트의 매크로는 아주 강력합니다. C/C++의 매크로는 문자열 치환 정도의 기능을 가지는데 비해 러스트의 매크로는 코드의 맥락을 이해할 수 있고, 컴파일 타임에 경고를 줄 수도 있는등 메타프로그래밍을 지원합니다.</p><p>napi-rs는 rust의 강력한 매크로를 사용해 <strong>컴파일 타임</strong>에 함수/클래스의 이름, 함수의 인자 등 을 분석하고, 적절한 헬퍼함수를 삽입하는 등 코드를 변형해 Node API를 사용하게 해줍니다.</p><p>러스트의 매크로에 대해 더 알아보고 싶다면 <a href="https://doc.rust-lang.org/book/first-edition/macros.html" target="_blank" rel="noopener noreferrer">공식문서의 매크로 항목</a>과 <a href="https://blog.cloudflare.com/ko-kr/writing-complex-macros-in-rust-reverse-polish-notation-ko-kr/" target="_blank" rel="noopener noreferrer">Rust 로 복잡한 매크로를 작성하기: 역폴란드 표기법</a>글을 추천합니다.</p><h1>편리한 빌드 / 배포 시스템</h1><p>napi-rs의 또다른 장점은 편리한 빌드 시스템입니다. napi-rs의 빌드 시스템은 노드에서 주로 사용되는 빌드 시스템의 불편한 점과 배포 방법의 불편한점을 해결해줍니다.</p><h1>기존 시스템의 불편한점</h1><p>주로 사용되는 기존 시스템들은 아래와 같은 문제를 가지고 있었습니다.</p><h2>node-gyp</h2><p>노드의 많은 네이티브 애드온은 <a href="https://ko.wikipedia.org/wiki/GYP_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4)" target="_blank" rel="noopener noreferrer">GYP</a>와 <code>gyp</code>를 래핑한 <code>node-gyp</code>을 이용합니다. <code>gyp</code>은 크롬팀에서 개발한 <strong>크로스 플렛폼</strong>을 지원하는 C/C++ 빌드 도구 입니다.</p><p><code>gyp</code>의 정의 파일은 복잡할 뿐만 아니라 파이썬과 같은 외부 의존성을 가지고 있습니다. gyp을 만든 크롬팀도 유지보수 등의 문제로 새로운 빌드도구 <a href="https://ko.wikipedia.org/wiki/GN_(%EB%B9%8C%EB%93%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C)" target="_blank" rel="noopener noreferrer">GN</a>을 개발해 GYP을 더이상 사용하지 않습니다.</p><p>실제로 노드와 deno를 만든 Ryan Dahl은 node.js에서 후회하는 것 중 하나로 꼽기도 했습니다.</p><iframe style="aspect-ratio:16 / 9" src="https://www.youtube.com/embed/M3BM9TB-8yA?cc_lang_pref=ko&amp;cc_load_policy=1&amp;start=420" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="c-bHVmPA"></iframe><p>위와 같은 이유로 노드 애드온 개발에 <a href="https://github.com/cmake-js/cmake-js" target="_blank" rel="noopener noreferrer">cmake-js</a>를 사용하는 경우도 있습니다.</p><h2>패키지 배포의 문제</h2><p>위에서 설명한 것처럼 NAN은 소스코드는 서로 다른 노드버전이라도 호환되지만, 컴파일된 결과물은 호환 되지않습니다. 이와같은 문제로 많은 패키지들이 C/C++ 소스코드를 제공하고 <code>postinstall</code>에서 컴파일 하는 방식으로 배포되었습니다.</p><p>조금 더 세련된 방식은 <a href="https://github.com/mapbox/node-pre-gyp" target="_blank" rel="noopener noreferrer">node-pre-gyp</a>을 이용해 사전에 컴파일된 바이너리가 있다면 CDN에서 받아오고, 만약 받아오는데 실패한다면 컴파일을 하는 방식도 널리 이용됩니다.</p><p>아마 여러분의 노드 프로젝트를 보시면 종종 <code>node_modules</code>내부에 <code>node-gyp</code>또는 <code>node-pre-gyp</code>이 보일겁니다.</p><p>이런 방식은 몇가지 문제점이 있습니다.
우선, 런타임에 불필요한 도구들을 설치해야합니다. <code>node-gyp</code>을 사용하려면 파이썬, make, gcc등이 있어야 합니다. 이런 이유로 노드만 사용하는 도커 이미지에 파이썬과 make등이 추가로 설치되어 용량의 증가와 관리에 어려움을 겪기도 합니다. cmake-js를 이용해도 C/C++ 소스를 배포한다면 런타임에 불필요한 도구를 설치해야한다는점은 동일합니다.</p><p>CDN을 활용하는 방법도 CDN의 속도나 방화벽등의 문제를 겪을 수 있습니다. 아마 AWS S3리전이 북미등 먼 지역으로 되어있어 설치가 아주 오래 걸린 경험을 해본 분들도 많이 계실겁니다.</p><h1>napi-rs의 빌드/배포 시스템</h1><p>napi-rs는 <a href="https://github.com/evanw/esbuild/tree/master/npm" target="_blank" rel="noopener noreferrer">esbuild</a>처럼 여러 플랫폼의 패키지를 생성하며, 이를 기본 패키지의 <code>optionalDependencies</code>에 추가하고 바인딩 코드를 제공합니다.</p><p>사용자는 기본 패키지만 설치하면 <code>optionalDependencies</code>도 설치되며, 기본 패키지에 해당 플랫폼에 맞는 파일을 골라 실행하는 코드가 있어 필요한 패키지를 실행하게 됩니다.</p><p>이 방법은 npm을 이용하기 때문에 방화벽 설정이나 속도에서 이점이 있고, 특정 플렛폼의 빌드가 복잡하다면 따로 관리할 수 있는 장점이 있습니다.</p><p><code>optionalDependencies</code>를 사용하기때문에 배포시 설치되지 않아도 문제없이 넘어가는 특징이 있어, 설령 다른 플랫폼의 패키지를 못 가져와도 동작하지만 만약 이 기능이 불안하시다면 기본 패키지에 여러 플랫폼에 맞는 <code>.node</code>파일을 만들어도 됩니다. napi-rs가 생성하는 바인딩 코드는 <code>some-package-darwin-x64.node</code> 같은 파일을 먼저 탐색하고 해당파일이 없다면 <code>@some-package/darwin-x64</code>파일을 불러오기 때문에 한 패키지에 모든 플렛폼을 지원하도록 할 수도 있습니다.</p><p>그리고 원한다면 위 과정을 자동으로 수행하는 GitHub Action 스크립트를 만들어 줍니다.</p><h3>Tip</h3><p>참고  로 yarn을 사용한다면 3.1 버전부터 <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#conditional-packages" target="_blank" rel="noopener noreferrer">supportedArchitectures</a> 설정을 통해 불필요한 <code>optionalDependencies</code>를 받지 않도록 설정 할 수 있습니다.</p><h2>TypeScript</h2><p>napi-rs의 빌드 시스템의 또 다른 장점은 러스트 코드를 보고 타입스크립트 지원을 위한 <code>.d.ts</code>을 자동으로 생성해줍니다. 이 역시 러스트의 매크로를 활용하여 함수의 정보를 받아와 생성해줍니다.</p><h2>Cargo = ❤️</h2><p>마지막으로 napi-rs의 장점은 러스트의 개발환경 입니다. <a href="https://github.com/hahnlee/canter" target="_blank" rel="noopener noreferrer">canter</a>라는 라이브러리를 개발하던 도중 <code>Objective-C</code>로 개발된 코드와 연동할 일이 많아 차라리 C/C++/Obj-C로 개발환경을 바꿀까 하는 고민을 많이 했었는데요, 개발을 하면 점점 더 그런 고민이 사라졌습니다.</p><p>C/C++에 비해 Cargo라는 표준적, 현대적인 패키지매니저 덕분에 다양한 라이브러리를 쉽게 사용할 수 있었고, 개발환경을 설치하기 위한 과정도 몹시 간단한데다 크로스플랫폼 빌드도 더 간단합니다.</p><p>러스트언어도 다양한 자료구조, 안전함을 제공하는것도 매력이고요.</p><p>C/C++ 연동도 러스트와 Cargo의 기능만으로도 가능하지만, 복잡한 경우에도 <a href="https://github.com/rust-lang/cc-rs" target="_blank" rel="noopener noreferrer">cc</a>같은 도구를 이용하면 비교적 어렵지 않았습니다.
Rust와 함께 사용할 C/C++ 코드가 크로스 플렛폼 빌드가 필요하다면 napi-rs의 --zig 옵션을 통해 <code>zig cc</code>를 사용할 수도 있습니다. (zig cc도 정말 멋진도구 입니다! 따로 소개할 예정이니 기대해주세요 😆)</p><p>만약 네이티브 연동이 필요하시다면 러스트와 napi-rs를 한번 사용해보세요. 아마 후회하지 않을겁니다.</p></article><div class="c-jEDjTQ"><img src="/images/profile.png" draggable="false" alt="" class="c-dvRuTq"/><div class="c-bZcNek"><h2 class="c-jwOSHF">이한</h2><p class="c-dMmbPO">Coding a Better World Together</p><a role="menuitem" href="https://hanlee.io" class="c-euCchw">About</a><a role="menuitem" href="https://github.com/hahnlee" class="c-euCchw">GitHub</a><a role="menuitem" href="/rss.xml" class="c-euCchw">RSS</a></div></div></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-111601591-4', 'auto', {});
      
      
      
      
      
      }</script><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/2022/napi-rs";window.___webpackCompilationHash="daf554781773296ec359";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-38856857010c707155ba.js"],"app":["/app-ffbf6f45867c65215e0e.js"],"component---src-containers-post-tsx":["/component---src-containers-post-tsx-355c941244c34af25b94.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-87b3ba1c8c14ae231405.js"]};/*]]>*/</script><script src="/polyfill-38856857010c707155ba.js" nomodule=""></script><script src="/app-ffbf6f45867c65215e0e.js" async=""></script><script src="/framework-043a7c4ea56bed9a642b.js" async=""></script><script src="/webpack-runtime-e753762912d8057d923a.js" async=""></script></body></html>