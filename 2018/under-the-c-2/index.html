<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/component---src-templates-post-jsx.8e06ea8d76deca4a57f1.css">code[class*=language-],pre[class*=language-]{color:#f8f8f2;background:none;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#272822}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#f8f8f2}.namespace{opacity:.7}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a6e22e}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.class-name,.token.function{color:#e6db74}.token.keyword{color:#66d9ef}.token.important,.token.regex{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.ArticleCard-module--articleCard--11z6V{display:flex;flex-wrap:nowrap;flex-direction:column;justify-content:space-between;height:24rem;padding:1rem;text-decoration:none}.ArticleCard-module--articleCard--11z6V .ArticleCard-module--title--1qLBI{font-size:1.75rem;word-break:keep-all;margin:0;line-height:1.2}.ArticleCard-module--articleCard--11z6V .ArticleCard-module--timeToRead--30lQv{text-align:right;line-height:1.2}.ArticleCard-module--articleCard--11z6V .ArticleCard-module--timeToRead--30lQv i{font-size:1rem;margin-right:.25rem;vertical-align:top}.ArticleGroup-module--articleGroup--1Rojv{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;grid-gap:1rem;padding-bottom:1rem}.Footer-module--footer--VUGIP{border-top:1px solid rgba(0,0,0,.14);color:#a5a5a5}.Footer-module--footer--VUGIP .Footer-module--content--3u_Ao{max-width:1200px;margin:0 auto;padding:1rem 0}.NavBar-module--navBar--34wO1{height:56px;padding:0 .5rem;position:fixed;background:#fff;width:100%;top:0;right:0}.NavBar-module--navBar--34wO1 .NavBar-module--content--1z5Z5{display:flex;width:100%;height:100%;max-width:1200px;margin:0 auto;align-items:center;justify-content:space-between}.NavBar-module--navBar--34wO1 .NavBar-module--homeLink--2g7Yn{color:#61bfad;font-size:2rem;font-weight:700;font-style:italic;text-decoration:none}.NavBar-module--navBar--34wO1 .NavBar-module--links--lZl1w a{padding:0 .5rem;color:#a5a5a5;text-decoration:none}.Page-module--page--2nMky{display:flex;flex-direction:column;width:100%;height:100%}.Page-module--page--2nMky .Page-module--content--pXhYh{flex:1 1;flex-wrap:nowrap;width:100%;max-width:1200px;padding-top:56px;margin:0 auto}a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}dl,ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:"";content:none}table{border-spacing:0}*,:after,:before{box-sizing:border-box}code,pre{font-family:Menlo,Courier New,Monaco,Spoqa Han Sans,monospace}code.language-text{padding:.25em .5em!important;font-size:85%!important;color:#364fc7!important;background-color:#f1f3f5!important;border-radius:3px!important;text-shadow:none!important}html{font-size:18px}body{font-family:Spoqa Han Sans,Source Sans Pro,Apple SD Gothic Neo,Nanum Barun Gothic,Nanum Gothic,Verdana,Arial,Dotum,sans-serif;color:#343a40;line-height:1.6}body,html{font-family:sans-serif}body,body>div,body>div>div,html,html>div,html>div>div{width:100%;height:100%;padding:0;margin:0}h1,h2,h3,h4,h5,h6{line-height:1.7;margin:1em 0 15px;padding:0}@media screen and (max-width:640px){h1,h2,h3,h4,h5,h6{line-height:1.4}}h1,h2,h3,h5{font-weight:700}h1{font-size:30px}h1 a{color:inherit}h2{font-size:24px}h3,h4{font-size:20px}h4,h6{color:#868e96}p{color:#343a40;margin:15px 0}a{text-decoration:none;cursor:pointer}a,a:active,a:hover{color:#1b6ec2}em,i{font-style:italic}b,strong{font-weight:700}sub{vertical-align:sub}sub,sup{font-size:smaller}sup{vertical-align:super}hr{border:0;border-top:1px solid #f1f3f5;margin:1.5em auto}ol>li:before,ul>li:before{position:absolute;width:1.4em;margin-left:-1.4em;display:inline-block;box-sizing:border-box;text-align:right}ul>li:before{content:"\2022";padding-right:.3em;font-family:inherit;font-size:1.4em;line-height:1.2}ol{counter-reset:section}ol>li:before{counter-increment:section;content:counter(section) ".";padding-right:.3em;font-family:inherit;font-size:1em;line-height:inherit}ol>li,ul>li{margin:0 auto .4em 1.4em;line-height:1.55}ol>li>ol,ol>li>ul,ul>li>ol,ul>li>ul{margin-top:.4em}li>ol>li,li>ul>li{font-size:.95em;margin:0 auto .38em 1.33em}dt{float:left;width:180px;overflow:auto;clear:left;text-align:right;white-space:nowrap;font-weight:700;margin-bottom:.4em}@media screen and (max-width:640px){dt{width:120px}}dd{margin-left:200px;margin-bottom:.4em}@media screen and (max-width:640px){dd{margin-left:140px}}table{margin-bottom:1rem;width:100%;border:1px solid #e9ecef;border-collapse:collapse}td,th{padding:.25rem .5rem;border:1px solid #e9ecef}tbody tr:nth-child(odd) td,tbody tr:nth-child(odd) th{background-color:#f1f3f5}blockquote{font-weight:300;padding:0 0 0 1.4rem;margin:0 2rem 1rem 0;border-left:.2em solid #dee2e6}blockquote p{color:#868e96}blockquote p:last-child{margin-bottom:0}</style><meta name="generator" content="Gatsby 2.0.78"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><link as="script" rel="preload" href="/webpack-runtime-749996d730c0a6ec41d9.js"/><link as="script" rel="preload" href="/app-6f8fe7d4739b6c28c3fe.js"/><link as="script" rel="preload" href="/0-3c6168db665e3ebc88dc.js"/><link as="script" rel="preload" href="/component---src-templates-post-jsx-cbc64e6f9662e6ace08a.js"/><link as="fetch" rel="preload" href="/static/d/426/path---2018-under-the-c-2-5-b-9-0f0-qt3BB6KBIi7UKiJTFn1TcBpBU5w.json" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="Page-module--page--2nMky"><nav class="NavBar-module--navBar--34wO1"><div class="NavBar-module--content--1z5Z5"><a class="NavBar-module--homeLink--2g7Yn" href="/">HAN LEE</a><section class="NavBar-module--links--lZl1w"><a href="https://hanlee.io" target="_blink">ABOUT</a><a href="/resume.pdf" target="_blink">RESUME</a><a href="https://vimrc.io" target="_blink">VIMRC.IO</a><a href="https://kodocs.io" target="_blink">KODOCS.IO</a></section></div></nav><main class="Page-module--content--pXhYh"><h1>Under the C: PyObject</h1><p>2018-04-21</p><div><p>파이썬의 모든 것은 객체다. 당연하게 들릴 수 있으나 객체 지향 언어라고 하려 모든것이 객체인건 아니다.
예를 들어 자바의 거의 모든것은 객체지만, 원시 자료형 (Primitive Type)은 아니다.
그러나 파이썬은 숫자도 객체다.</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">42</span><span class="token punctuation">.</span><span class="token punctuation">.</span>__add__<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># 점을 두개 붙어야 호출 가능하다</span>
<span class="token number">45.0</span></code></pre></div>
<p>이와 같은 이유로 객체를 알아보는건 파이썬 내부를 알아보는데 좋은 출발점이다.</p>
<h1>PyObject</h1>
<p>파이썬의 객체는 <code class="language-text">PyObject</code>로 이뤄져 있다.
<code class="language-text">PyObject</code>는 <code class="language-text">Include</code> 폴더의 <code class="language-text">object.h</code>에 다음과 같이
<a href="https://github.com/python/cpython/blob/f320be7/Include/object.h#L106">정의</a>
되어 있다.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _object <span class="token punctuation">{</span>
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> _typeobject <span class="token operator">*</span>ob_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span> PyObject<span class="token punctuation">;</span></code></pre></div>
<p>이중 <code class="language-text">_PyObject_HEAD_EXTRA</code>매크로는 디버깅에만 사용되므로 무시하자.
따라서 <code class="language-text">PyObject</code>는 다음의 구조체다.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _object <span class="token punctuation">{</span>
    Py_ssize_t ob_refcnt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> _typeobject <span class="token operator">*</span>ob_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span> PyObject<span class="token punctuation">;</span></code></pre></div>
<p><code class="language-text">_typeobject</code>는 외부에는 <code class="language-text">PyTypeObject</code>라는 이름으로 사용된다.
이름처럼 객체에 관한 정보가 기록 된다. <code class="language-text">PyTypeObject</code>의 자세한 소스코드는 <a href="https://github.com/python/cpython/blob/f320be7/Include/object.h#L346">GitHub</a>을 참고하라.
예를 들어 파이썬 객체의 <code class="language-text">__doc__</code>정보는 <code class="language-text">PyTypeObject</code>의 <code class="language-text">tp_doc</code>필드에 저장된다.</p>
<p>따라서 필요하다면 C언어로 <code class="language-text">PyTypeObject</code>를 상속받아 새로운 객체를 만들 수도 있다.
<code class="language-text">PyTypeObject</code>의 내용은 다음에 다루기로 하고, 지금은 다른 필드 <code class="language-text">ob_refcnt</code>를 알아보자.
변수명에서 눈치 챘겠지만, 레퍼런스 카운팅(이하 RC)을 위한 필드다.</p>
<h1>Reference Counting</h1>
<p>파이썬의 주 메모리 관리는 RC로 이뤄진다.
RC는 객체가 얼마나 사용되는지 레퍼런스 카운트에 기록한다.
객체가 사용되는 만큼 레퍼런스 카운트를 1씩 증가/감소하며, 레퍼런스 카운트가 0이 되면 메모리에서 해제한다.</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Foo("{}")가 메모리에서 제거 되었습니다'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>  <span class="token comment"># Foo("a")가 새로 생성 되었으므로 레퍼런스 카운트는 1이 된다</span>
b <span class="token operator">=</span> a  <span class="token comment"># B도 a를 참조 있으므로 Foo의 레퍼런스 카운트는 2가 된다</span>

b <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># B가 더이상 Foo("a")를 사용하지 않으므로 Foo("a")의 레퍼런스 카운트는 1 줄어 들어 1 이 된다</span>
a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># a도 더이상 Foo("a")를 사용하지 않으므로 Foo("a")의 레퍼런스 카운트는 1 줄어 0이 되어, 해재하며 소멸자를 호출한다</span></code></pre></div>
<p>파이썬에서 <code class="language-text">__init__</code>는 생성자, <code class="language-text">__del__</code>은 소멸자이다.
위 코드를  <strong>인터프리터 모드</strong>에서 실행하면 <code class="language-text">a = None</code>을 실행한 직후 <code class="language-text">Foo(&quot;a&quot;)가 메모리에서 제거 되었습니다</code>라는 메시지를 볼 수 있을 것이다.
이처럼 RC를 사용하면 메모리가 필요 없어진 순간 제거 된다.</p>
<p>파이썬 내부에선 Reference Count 관리를 위해 <code class="language-text">Py_INCREF</code>와 <code class="language-text">Py_DECREF</code>를 사용한다.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> Py_INCREF(op) (                         \
    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \
    ((PyObject *)(op))->ob_refcnt++)</span></code></pre></div>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> Py_DECREF(op)                                   \
    do {                                                \
        PyObject *_py_decref_tmp = (PyObject *)(op);    \
        if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \
        --(_py_decref_tmp)->ob_refcnt != 0)             \
            _Py_CHECK_REFCNT(_py_decref_tmp)            \
        else                                            \
            _Py_Dealloc(_py_decref_tmp);                \
    } while (0)</span></code></pre></div>
<p><code class="language-text">_Py_DEC_REFTOTAL</code>, <code class="language-text">_Py_REF_DEBUG_COMMA</code> 처럼 디버그에서 사용하는 내용을 지우면,
<code class="language-text">Py_INCREF</code>는 다음과 같으며,</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token punctuation">(</span><span class="token punctuation">(</span>PyObject <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>ob_refcnt<span class="token operator">++</span><span class="token punctuation">;</span></code></pre></div>
<p><code class="language-text">Py_DECREF</code>는 다음과 같다.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">PyObject <span class="token operator">*</span>_py_decref_tmp <span class="token operator">=</span> <span class="token punctuation">(</span>PyObject <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span>_py_decref_tmp<span class="token punctuation">)</span><span class="token operator">-></span>ob_refcnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token function">_Py_Dealloc</span><span class="token punctuation">(</span>_py_decref_tmp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>RC를 사용하면 프로그래머가 큰 신경을 쓰지 않아도, 필요 없다고 판단된 메모리는 그 즉시 해제할 수 있다.
개인적으로 RC는 <em>비용있는</em> 추상화 방식 중에서는 가장 우아한 방식이라고 생각한다.
아래의 문제점들만 없다면 말이다.</p>
<h1>문제</h1>
<p>메모리관리에 대해 알아본 프로그래머라면 알겠지만, 아쉽게도 RC는 만병통치약이 아니다.</p>
<h2>오버헤드</h2>
<p>첫번째로 오버헤드를 이야기 할 수 있다.
우선 <code class="language-text">PyObject</code>의 <code class="language-text">ob_refcnt</code> 처럼 레퍼런스 카운트를 저장할 공간이 추가적으로 필요하고,
변수를 할당할때도 추가적으로 레퍼런스 카운트를 관리해야 한다.</p>
<p><a href="https://blog.sn0wle0pard.io/2018/under-the-c-1/">저번 글</a>에 나온 내용을 다시 살펴보자.</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">if</span> A <span class="token operator">!=</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span></code></pre></div>
<p>파이썬 인터프리터에게 위 코드는 다음의 C 코드와 비슷하다.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">PyObject <span class="token operator">*</span>T <span class="token operator">=</span> Py_True<span class="token punctuation">;</span>
<span class="token function">Py_INCREF</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PyObject_RichCompareBool</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> T<span class="token punctuation">,</span> Py_NE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token function">Py_DECREF</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>변수 <code class="language-text">A</code>와 <code class="language-text">True</code>를 비교하기 위해 임시 변수 <code class="language-text">T</code>를 만들었고, T는 <code class="language-text">Py_True</code>값을 참조 한다.
아쉽게도 단순히 참조에서 끝나는게 아니라 필요에 따라 <code class="language-text">Py_INCREF</code>와 <code class="language-text">Py_DECREF</code>가 호출 된다.</p>
<p>오버헤드는 메모리 관리에 드는 수고를 생각하면 넘어갈 수 있을 수도 있다.
그러나 아쉽게도 해제할 수 없는 메모리도 있다.</p>
<h2>순환참조</h2>
<p>RC는 안전하지만 완전하진 않다.
모든 해제된 메모리는 필요 없는 메모리지만, 모든 필요없는 메모리가 헤제되는건 아니다.</p>
<p>예를 들어 다음의 코드를 보자,</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    child <span class="token operator">=</span> <span class="token boolean">None</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Foo("{}")가 메모리에서 제거 되었습니다'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>  <span class="token comment"># Foo("a")의 ref count는 1</span>
b <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span>  <span class="token comment"># Foo("b")의 ref count는 1</span>

a<span class="token punctuation">.</span>child <span class="token operator">=</span> b  <span class="token comment"># a.child가 Foo("b")를 참조하므로 Foo("b")의 레퍼런스 카운트는 1 증가하여 2가 된다</span>
b<span class="token punctuation">.</span>child <span class="token operator">=</span> a  <span class="token comment"># b.child가 Foo("a")를 참조하므로 Foo("a")의 레퍼런스 카운트는 1 증가하여 2가 된다</span>

a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># a가 더이상 Foo("a")를 참조하지 않으므로 레퍼런스 카운트는 1 감소해서 1 이다</span>
b <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># b가 더이상 Foo("b")를 참조하지 않으므로 레퍼런스 카운트는 1 감소해서 1 이다</span>

<span class="token comment"># Foo("a")와 Foo("b")모두 접근할 수 없지만, 레퍼런스 카운트가 남아 있으므로 해재되지 않는다</span></code></pre></div>
<p>위 코드를  <strong>인터프리터 모드</strong>에서 실행하면 <code class="language-text">a = 0</code>이나 <code class="language-text">b = 0</code>이 되면 더이상 <code class="language-text">Foo(&quot;a&quot;)</code>와 <code class="language-text">Foo(&quot;b&quot;)</code>에 접근 할 수 없다.
그러나 <code class="language-text">a.child</code>와 <code class="language-text">b.child</code>의 참조때문에 올라간 레퍼런스 카운트가 존재해 a와 b가 더이상 child에 접근 못 하더라도 해제가 불가능 하다.</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    child <span class="token operator">=</span> <span class="token boolean">None</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Foo("{}")가 메모리에서 제거 되었습니다'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>  <span class="token comment"># Foo("a")의 ref count는 1</span>
a<span class="token punctuation">.</span>child <span class="token operator">=</span> a  <span class="token comment"># a.child가 Foo("a")를 참조하므로 Foo("a")의 레퍼런스 카운트는 1 증가하여 2가 된다</span>

a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># a가 더이상 Foo("a")를 참조하지 않으므로 레퍼런스 카운트는 1 감소해서 1 이다</span>

<span class="token comment"># Foo("a")에 접근할 수 없지만, 레퍼런스 카운트가 남아 있으므로 해재되지 않는다</span></code></pre></div>
<p>또 하나, 위처럼 자기 자신을 참조하는 경우도 마찬가지로 해재할 수 없다.
이 처럼 서로 참조하는 경우를 <strong>순환참조</strong>라고 하며, 레퍼런스 카운트로는 해결하기 까다롭다.</p>
<p>좀 더 쉬운 예를 하나 보면,</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python">x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span></code></pre></div>
<p>파이썬의 경우 위의 코드는 자기자신을 참조한다.</p>
<h1>GC</h1>
<p>이러한 이유로 파이썬은 RC만을 사용하지 않고, 추가적으로 GC도 사용한다.
엄밀하게 말하면 RC도 GC의 일부지만 이 글에선 RC가 아닌 GC를 말하기로 하자.
파이썬의 GC는 <code class="language-text">gcmodule.c</code>에 <a href="https://github.com/python/cpython/blob/master/Modules/gcmodule.c">정의</a> 되어 있으며,
자세한 내용은 추후에 다루도록 하겠다.</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    child <span class="token operator">=</span> <span class="token boolean">None</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Foo("{}")가 메모리에서 제거 되었습니다'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>  <span class="token comment"># a의 ref count는 1</span>
b <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span>  <span class="token comment"># b의 ref count는 1</span>

b<span class="token punctuation">.</span>child <span class="token operator">=</span> a  <span class="token comment"># a의 ref count는 2</span>
a<span class="token punctuation">.</span>child <span class="token operator">=</span> b  <span class="token comment"># b의 ref count는 2</span>

a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># a의 ref count는 1 감소해서 1 이다 (b.child에 참조가 남아있다)</span>
b <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># b의 ref count는 1 감소해서 1 이다 (a.child에 참조가 남아있다)</span>

<span class="token keyword">import</span> gc
gc<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># GC를 직접 호출해보자 (원래는 필요한 경우 자동으로 호출 된다)</span></code></pre></div>
<p>위의 코드를 실행하면 <code class="language-text">gc.collect()</code>가 더이상 접근할 수 없는 객체를 해재하는 것을 볼 수 있다.
특별한 설정을 하지 않는다면 파이썬은 자동으로 필요할때 gc를 호출해 RC로 해재할 수 없는 객체를 해제해 준다.</p>
<p>GC도 사용하므로 파이썬의 메모리 관리는 아쉽게도 RC하나만 사용하는 것에 비해 추가적인 비용이 든다.</p>
<p>다행인 점은 파이썬의 GC는 순환참조를 만들 가능성이 있는 컨테이너 객체를 대상으로 사용되어 모든 객체를 검사하진 않는다.</p>
<p>실제로, GC는 파이썬 2.0 버전부터 도입 되었으며 <a href="http://www.arctrix.com/nas/python/gc/">당시 자료</a>를 보면 이전 버전에 비해 약 4%의 성능 저하의 원인으로 생각한다고 한다.</p>
<p>이런 이유로 성능에 여유가 없거나, 순환참조를 피할 자신이 있다면 <code class="language-text">gc.disable()</code>로 GC를 꺼도 된다.
대표적으로 <a href="https://instagram-engineering.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172">인스타그램</a>은 GC를 사용하지 않는다고 한다.</p>
<h2>덤: 약한참조</h2>
<p>다른 RC를 사용하는 언어를 사용한 분들은 들어본적이 있겠지만,
순환참조로 인한 메모리 누수를 피하는 또다른 방법은 <strong>약한참조</strong>가 있다.</p>
<p>쉽게 설명하면 참조는 하되, 레퍼런스 카운트는 올리지 않는 것이다.
파이썬은 <code class="language-text">weakref</code>모듈을 통해 약한 참조를 사용할 수 있다.</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    child <span class="token operator">=</span> <span class="token boolean">None</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Foo("{}")가 메모리에서 제거 되었습니다'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>  <span class="token comment"># a의 ref count는 1</span>
b <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span>  <span class="token comment"># b의 ref count는 1</span>

<span class="token keyword">import</span> weakref

<span class="token comment"># weakref를 사용했으므로 레퍼런스 카운트는 변화하지 않는다</span>
a<span class="token punctuation">.</span>child <span class="token operator">=</span> weakref<span class="token punctuation">.</span>ref<span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment"># Foo("b")의 레퍼런스 카운트는 여전히 1 이다</span>
b<span class="token punctuation">.</span>child <span class="token operator">=</span> weakref<span class="token punctuation">.</span>ref<span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment"># Foo("a")의 레퍼런스 카운트는 여전히 1 이다</span>

<span class="token comment"># 그러나 접근은 가능하다</span>
<span class="token comment"># child 자체는 weakref 객체이므로 호출을 통해 가리키는 객체를 가져올수 있다</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>

a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># Foo("a")의 레퍼런스 카운트는 1 감소해서 0 이다</span>
<span class="token comment"># 소멸자가 호출된다</span>

<span class="token comment"># 더이상 접근이 불가능하므로 None이 반환된다</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

b <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># Foo("b")의 레퍼런스카운트는 1 감소해서 0 이다</span>
<span class="token comment"># 소멸자가 호출된다</span></code></pre></div>
<p><code class="language-text">weakref</code>는 접근이 가능하면 해당 객체를, 해당객체가 접근 불가능 하면 <code class="language-text">None</code>을 반환한다.</p>
<h1>RC와 GIL</h1>
<p>CPython은 멀티 <em>스레드</em>를 효율적으로 사용하지 못한다.
한 파이썬 프로세스는 한번에 한 스레드만 사용하며, 이를 GIL (Global interpreter lock) 이라고 부른다.</p>
<p>CPython에서 GIL을 제거하려는 시도는 종종 있지만, 아직까지는 GIL이 남아 있다.
그 이유중 하나가 바로 RC 때문이다.</p>
<p>다만 GIL 자체는 선택사항이며 원한다면 RC를 쓰고도 GIL을 제거 할 수도 있다.
잠시 다른 파이썬 구현체를 보자.</p>
<ul>
<li>Jython은 GC로 관리 하며, GIL이 없다</li>
<li>IronPython은 GC로 메모리 관리 하며, GIL이 없다</li>
<li>PyPy는 GC로 메모리 관리를 하며, GIL이 <em>있다</em></li>
</ul>
<p>PyPy가 대표적으로 GC만 사용하나, GIL이 존재한다.
그러나, PyPy는 2017년 8월 블로그글 <a href="https://morepypy.blogspot.kr/2017/08/lets-remove-global-interpreter-lock.html">Let's remove the Global Interpreter Lock</a>를 통해 GIL을 제거할 수 있음을 알렸다.</p>
<p>PyPy의 블로그 글에 따르면 CPython에서 GIL을 제거하기 힘든 두가지 이유는 다음과 같다.</p>
<ul>
<li>how do we guard access to mutable data structures with locks and</li>
<li>what to do with reference counting that needs to be guarded.</li>
</ul>
<p>멀티스레드에서 발생하는 문제중 하나는 여러 스레드가 동시에 한 변수를 수정하려는 문제이다.
멀티스레드를 사용해본 경험이 있다면 <code class="language-text">lock guard</code>와 <code class="language-text">mutex</code>등을 보거나 사용해본 점이 있을 것이다.</p>
<p>그렇다면 스레드간 공유하는 객체는 읽기만 가능하고, 수정은 못하게 한다면 되지 않을까?
좋은 접근이지만 RC를 사용하면 쉽지많은 않은 일이다.</p>
<p>다시 위의 코드를 보자</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">import</span> sys


<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">read_foo</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>foo<span class="token punctuation">)</span>

read_foo<span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment"># read_foo의 매개변수 foo가 a를 참조 있으므로 Foo의 레퍼런스 카운트는 증가하였다</span>
<span class="token comment"># read_a 함수가 끝나면 레퍼런스 카운트는 다시 줄어든다</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div>
<p><code class="language-text">getrefcount</code>는 객체의 레퍼런스 카운트 갯수를 구하는 함수다.
우리가 생각한 레퍼런스 카운트 횟수보다 좀 더 많을 텐데 <a href="https://docs.python.org/3/library/sys.html#sys.getrefcount">문서</a>의 내용에 따르면, <code class="language-text">getrefcount</code>함수를 실행하기 위해 매개변수로 참조 카운트가 증가 하여 그렇다.</p>
<p>내용으로 돌아가면 <code class="language-text">read_foo</code>는 <code class="language-text">a</code>의 내용을 읽기만 하고 수정하진 않았지만, 매개변수등 참조가 일어 날때마나 <code class="language-text">obj_refcnt</code>는 증/감 한다.
여러 스레드가 동시에 참조를 만든다면 동시수정과 다름 없는 상태가 된다.</p>
<p>추가로 RC를 사용하고도 이 문제를 피할 방법 자체는 있다.
예를 들어 <code class="language-text">std::atomic</code>이 있다(<a href="http://www.cplusplus.com/reference/atomic/atomic/">C++ 문서</a>).
atomic은 DB의 Atomic 성질 처럼 순서대로 진행하는걸 보장하는데,
즉 두 스레드가 거의 동시에 레퍼런스 카운트를 변화 하려고 하면, 먼저 요청한 스레드의 요청대로 한 obj_refcnt를 변화시키고, 그 다음 스레드 요청을 처리한다.</p>
<p>대표적인 예로 Rust의 <code class="language-text">Rc</code>와 <code class="language-text">ARc</code>가 있다.
Rust 자체는 무비용 추상화로 메모리를 관리하지만, 원한다면 RC로 관리되는 객체를 만들 수 있다.
이 경우 싱글 스레드면 <code class="language-text">Rc</code>를 멀티 스레드면 <code class="language-text">ARc</code>를 사용하면 되는데, <code class="language-text">ARc</code>는 레퍼런스 카운트가 atomic 하게 동작한다.</p>
<p>Atomic을 보장하는 것은 추가적인 오버헤드가 있다는 이야기다.
실제로 ARc <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">문서</a>를 보면,
원자성 보장은 일반 메모리 접근보다 비용이 많이 들고, 싱글스레드라면 비용을 줄이기 위에 <code class="language-text">Rc</code>를 쓸 수 있다고 언급하고 있다.</p>
<p>현재 파이썬의 대부분은 싱글 스레드 환경이며, 멀티스레드를 위해 싱글스레드 저하를 선택할 것인가는 논쟁의 여지가 있다.
현재로는 파이썬 커뮤니티는 멀티스레드 사용을 위해 싱글스레드 성능이 저하 되는 해결을 받아 들이고 싶어 하지 않는다.
<a href="https://wiki.python.org/moin/GlobalInterpreterLock?action=show&#x26;redirect=GIL">파이썬 위키</a>의 GIL 항목을 인용 하면</p>
<blockquote>
<p>The BDFL has said he will reject any proposal in this direction that slows down single-threaded programs.</p>
</blockquote>
<p>BDFL은 파이썬 창시자 귀도 반 로썸을 말한다. 위키백과의 설명을 인용한다.</p>
<blockquote>
<p>자비로운 종신독재자(BDFL, Benevolent Dictator for Life)란 소수의 오픈 소스 소프트웨어 개발 리더에게 부여되는 칭호이다. 주로 커뮤니티 내에서 논쟁이 있을 때 최종적으로 결론을 내려줄 수 있는, 프로젝트 창시자인 경우가 많다. 이 표현은 1995년에 파이썬의 창시자 귀도 반 로섬을 가리키는 호칭으로 처음 사용되었다.</p>
</blockquote>
<p>개인적으로도 멀티스레드를 위해 싱글스레드 성능저하가 심각하다면 받아 들이고 싶지 않다.</p>
<p>실제로 파이썬에 atomic 레퍼런스 카운트를 사용하게되면 <a href="https://greek0.net/blog/2015/05/23/python_atomic_refcounting_slowdown/">약 23%의 성능저하</a>를 보인다고 한다.</p>
<p>공유하는 객체만 원자성 보장을 하면 어떨까?
멀티 스레드를 사용하는 코딩을 해도 스레드간 공유될 객체가 몇 안될 것 같다고 생각한다면,
파이썬 콘솔을 켜서 다음 코드를 실행해 보길 권한다.</p>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
<span class="token number">2296</span></code></pre></div>
<p>글을 시작하며 언급한것 처럼 파이썬의 모든건 객체다.
단순한 값으로 생각할 수 있는 <code class="language-text">None</code>도 하나의 객체며 여러곳에서 공유하고 있다.
왜 어려운 문제인지 짐작 할 수 있을 것이다.</p></div></main><footer class="Footer-module--footer--VUGIP"><div class="Footer-module--content--3u_Ao">© 2018 Han Lee. All right Reserved.</div></footer></div></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-111601591-4', 'auto', {});
      
      }
      </script><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-post-jsx","jsonName":"2018-under-the-c-2-5b9","path":"/2018/under-the-c-2/"};window.dataPath="426/path---2018-under-the-c-2-5-b-9-0f0-qt3BB6KBIi7UKiJTFn1TcBpBU5w";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-6f8fe7d4739b6c28c3fe.js"],"component---src-templates-post-jsx":["/component---src-templates-post-jsx.8e06ea8d76deca4a57f1.css","/component---src-templates-post-jsx-cbc64e6f9662e6ace08a.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx.870d179f60c980211e3e.css","/component---src-pages-index-jsx-2ee03dd5c9559c5b3d07.js"],"pages-manifest":["/pages-manifest-71b80a4cb6c710f23b5a.js"]};/*]]>*/</script><script src="/component---src-templates-post-jsx-cbc64e6f9662e6ace08a.js" async=""></script><script src="/0-3c6168db665e3ebc88dc.js" async=""></script><script src="/app-6f8fe7d4739b6c28c3fe.js" async=""></script><script src="/webpack-runtime-749996d730c0a6ec41d9.js" async=""></script></body></html>