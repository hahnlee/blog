<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.20.0"/><meta property="og:type" content="article" data-gatsby-head="true"/><meta property="og:title" content="Under the C: PyObject" data-gatsby-head="true"/><meta property="og:description" content="파이썬의 모든 자료형의 부모 PyObject를 알아봅시다" data-gatsby-head="true"/><meta property="og:image" content="/static/3176fe09bf63006f0013bb98ac036702/fc269/thumbnail.jpg" data-gatsby-head="true"/><meta property="og:author" content="이한" data-gatsby-head="true"/><meta property="og:site_name" content="명시지(形式知) - 기록할 수 있는 지식을 나눕니다" data-gatsby-head="true"/><meta name="msapplication-TileColor" content="#000000" data-gatsby-head="true"/><meta name="theme-color" content="#000000" data-gatsby-head="true"/><meta property="article:author" content="이한" data-gatsby-head="true"/><meta name="twitter:label1" content="읽는 시간" data-gatsby-head="true"/><meta name="twitter:data1" content="4분" data-gatsby-head="true"/><style data-href="/styles.618336a6b0dc03f16839.css" data-identity="gatsby-global-css">@font-face{font-display:swap;font-family:Pretendard;font-weight:900;src:local("Pretendard Black"),url(/static/Pretendard-Black-14a71ec59ff2b3bc6933d54c6ee04ff1.woff2) format("woff2"),url(/static/Pretendard-Black-fe80bd8c7ce9b3af972f6e99a5646522.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:800;src:local("Pretendard ExtraBold"),url(/static/Pretendard-ExtraBold-55bef92e8f01b6b6ef2f8d31fdc0f951.woff2) format("woff2"),url(/static/Pretendard-ExtraBold-82ea4400a5eea299b40c94aac01985ba.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:700;src:local("Pretendard Bold"),url(/static/Pretendard-Bold-0676c8838a37a3b770d85a5534f5fdcb.woff2) format("woff2"),url(/static/Pretendard-Bold-f6866c5eb21ccb9a8749d3a2874a7e6e.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:600;src:local("Pretendard SemiBold"),url(/static/Pretendard-SemiBold-7e5eaaf650b9e738991373a7f173b94a.woff2) format("woff2"),url(/static/Pretendard-SemiBold-a0c72d6162af72df37ec279440595738.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:500;src:local("Pretendard Medium"),url(/static/Pretendard-Medium-ea235f1edb8815831a25b376b479949e.woff2) format("woff2"),url(/static/Pretendard-Medium-f902522b86842449110e07cbc07b8346.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:400;src:local("Pretendard Regular"),url(/static/Pretendard-Regular-6090e6b5524796768e78f23519d16488.woff2) format("woff2"),url(/static/Pretendard-Regular-ab56c53f21ca6b32d15fe0ae8daf5f60.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:300;src:local("Pretendard Light"),url(/static/Pretendard-Light-27c9a07cbc308ce88d1ab3613e3152c7.woff2) format("woff2"),url(/static/Pretendard-Light-40808ea4485a78c05f9213ed583b0046.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:200;src:local("Pretendard ExtraLight"),url(/static/Pretendard-ExtraLight-1a26bede4e9bc7d2e9c0ce548cd4cf83.woff2) format("woff2"),url(/static/Pretendard-ExtraLight-ff5e73a97b5e7a5c5d5fed684594e8ad.woff) format("woff")}@font-face{font-display:swap;font-family:Pretendard;font-weight:100;src:local("Pretendard Thin"),url(/static/Pretendard-Thin-41861ab4e67767c4c6ed0b5e361fbca6.woff2) format("woff2"),url(/static/Pretendard-Thin-348f24715998d74e9f5529afd376f55b.woff) format("woff")}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#000;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;-o-tab-size:4;tab-size:4;text-align:left;text-shadow:0 1px #fff;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#b3d4fc;text-shadow:none}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{background:hsla(0,0%,100%,.5);color:#9a6e3a}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><title data-gatsby-head="true">Under the C: PyObject | </title><link rel="alternate" type="application/rss+xml" title="명시지(形式知) - 기록할 수 있는 지식을 나눕니다" href="/rss.xml" data-gatsby-head="true"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png" data-gatsby-head="true"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png" data-gatsby-head="true"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png" data-gatsby-head="true"/><link rel="manifest" href="/favicon/site.webmanifest" data-gatsby-head="true"/><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="alternate" type="application/rss+xml" title="명시지 (形式知)" href="/rss.xml"/><link rel="preconnect" href="https://www.google-analytics.com"/><link rel="dns-prefetch" href="https://www.google-analytics.com"/><style id="stitches">--sxs{--sxs:0 t-gdxNDc}@media{:root,.t-gdxNDc{--colors-gray000:#F8F9FA;--colors-gray100:#F1F3F5;--colors-gray200:#E9ECEF;--colors-gray300:#DEE2E6;--colors-gray400:#CED4DA;--colors-gray500:#ADB5BD;--colors-gray600:#868E96;--colors-gray700:#495057;--colors-gray800:#343A40;--colors-gray900:#212529;--colors-blue700:#1C7ED6}}--sxs{--sxs:1 hKePEu}@media{body{padding:0;margin:0;font-size:16px;color:var(--colors-gray800);font-weight:400;font-family:Pretendard,sans-serif}*{box-sizing:border-box}}--sxs{--sxs:2 c-bSvfqS c-hEdiuM c-eAAbaD c-gGqMDa c-jEDjTQ c-dvRuTq c-bZcNek c-jwOSHF c-dMmbPO c-euCchw c-boZbfK c-gBKazA c-eXJruw c-fzsocY c-eJVyyl c-fXXVzC c-hdzxtM c-dpWDmP c-bxCTAm c-jDcCnV c-bvNJHJ}@media{.c-bSvfqS{max-width:1000px;padding:24px;margin:0 auto}.c-hEdiuM{width:36px;height:36px}.c-eAAbaD{font-size:18px;line-height:1.8;word-break:keep-all}.c-eAAbaD h1,.c-eAAbaD h2,.c-eAAbaD h3,.c-eAAbaD p{margin-top:0;margin-bottom:12px}.c-eAAbaD h1,.c-eAAbaD h2,.c-eAAbaD h3{font-weight:600}.c-eAAbaD h1{font-size:1.5rem}.c-eAAbaD h2{font-size:1.25rem}.c-eAAbaD h3{font-size:1.15rem}.c-eAAbaD a{color:var(--colors-blue700);text-decoration:none}.c-eAAbaD blockquote{margin:12px 0;padding:1px 16px;color:var(--colors-gray600);border-left:5px solid var(--colors-gray200)}.c-eAAbaD blockquote p{margin:4px 0}.c-eAAbaD iframe{display:block;max-width:100%;margin:0 auto;margin-bottom:18px}.c-eAAbaD pre[class*="language-"]{font-size:16px;border-radius:8px;background-color:var(--colors-gray000)}.c-eAAbaD pre[class*="language-"] .token.operator{background-color:var(--colors-gray000)}.c-eAAbaD .footnotes hr{border-top:none;border-color:var(--colors-gray200)}.c-gGqMDa{font-size:2rem;font-weight:600;margin-bottom:0 !important}.c-jEDjTQ{display:flex;align-items:center;margin-top:24px;background-color:var(--colors-gray000);border-radius:16px;padding:16px}.c-dvRuTq{width:72px;height:72px;border-radius:50%}.c-bZcNek{flex:1;margin-left:24px}.c-jwOSHF{margin:0;font-size:1.25rem;color:var(--colors-gray700);font-weight:600}.c-dMmbPO{margin:6px 0;font-weight:400;color:var(--colors-gray600)}.c-euCchw{font-size:0.85rem;color:var(--colors-gray600);margin-right:8px}.c-boZbfK{max-width:1000px;padding:100px 24px;margin:0 auto}@media screen and (max-width: 1000px){.c-boZbfK{padding:60px 24px}}.c-gBKazA{margin-bottom:24px}.c-eXJruw{color:var(--colors-gray700);font-size:1.75rem;font-weight:600;margin:0}.c-fzsocY{color:var(--colors-gray500);font-size:1.25rem}.c-eJVyyl{margin:0;margin-top:6px;color:var(--colors-gray600);font-weight:300;font-size:1rem}.c-fXXVzC{margin:0;padding:0}.c-hdzxtM{list-style:none;border-bottom:1px solid var(--colors-gray100)}.c-hdzxtM:last-child{border:none}.c-jDcCnV{font-size:1.25rem;color:var(--colors-gray700);font-weight:600;margin:0}.c-bvNJHJ{margin:0;margin-top:6px;color:var(--colors-gray600);font-weight:400}.c-bxCTAm{padding:16px;word-break:keep-all}.c-bxCTAm:hover{border-radius:12px;background-color:var(--colors-gray000)}.c-dpWDmP{display:block;text-decoration:none}}</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><main class="c-bSvfqS"><header><a href="/"><img src="/images/logo.png" draggable="false" alt="블로그 로고" width="36" height="36" class="c-hEdiuM"/></a></header><article class="c-eAAbaD"><h1 class="c-gGqMDa">Under the C: PyObject</h1><p>2018-04-20</p><p>파이썬의 모든 것은 객체다. 당연하게 들릴 수 있으나 객체 지향 언어라고 하려 모든것이 객체인건 아니다.
예를 들어 자바의 거의 모든것은 객체지만, 원시 자료형 (Primitive Type)은 아니다.
그러나 파이썬은 숫자도 객체다.</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token number">42.</span><span class="token punctuation">.</span>__add__<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># 점을 두개 붙어야 호출 가능하다</span>
<span class="token number">45.0</span></code></pre></div><p>이와 같은 이유로 객체를 알아보는건 파이썬 내부를 알아보는데 좋은 출발점이다.</p><h1>PyObject</h1><p>파이썬의 객체는 <code>PyObject</code>로 이뤄져 있다.
<code>PyObject</code>는 <code>Include</code> 폴더의 <code>object.h</code>에 다음과 같이
<a href="https://github.com/python/cpython/blob/f320be7/Include/object.h#L106">정의</a>
되어 있다.</p><div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_object</span> <span class="token punctuation">{</span>
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">_typeobject</span> <span class="token operator">*</span>ob_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span> PyObject<span class="token punctuation">;</span></code></pre></div><p>이중 <code>_PyObject_HEAD_EXTRA</code>매크로는 디버깅에만 사용되므로 무시하자.
따라서 <code>PyObject</code>는 다음의 구조체다.</p><div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_object</span> <span class="token punctuation">{</span>
    Py_ssize_t ob_refcnt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">_typeobject</span> <span class="token operator">*</span>ob_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span> PyObject<span class="token punctuation">;</span></code></pre></div><p><code>_typeobject</code>는 외부에는 <code>PyTypeObject</code>라는 이름으로 사용된다.
이름처럼 객체에 관한 정보가 기록 된다. <code>PyTypeObject</code>의 자세한 소스코드는 <a href="https://github.com/python/cpython/blob/f320be7/Include/object.h#L346">GitHub</a>을 참고하라.
예를 들어 파이썬 객체의 <code>__doc__</code>정보는 <code>PyTypeObject</code>의 <code>tp_doc</code>필드에 저장된다.</p><p>따라서 필요하다면 C언어로 <code>PyTypeObject</code>를 상속받아 새로운 객체를 만들 수도 있다.
<code>PyTypeObject</code>의 내용은 다음에 다루기로 하고, 지금은 다른 필드 <code>ob_refcnt</code>를 알아보자.
변수명에서 눈치 챘겠지만, 레퍼런스 카운팅(이하 RC)을 위한 필드다.</p><h1>Reference Counting</h1><p>파이썬의 주 메모리 관리는 RC로 이뤄진다.
RC는 객체가 얼마나 사용되는지 레퍼런스 카운트에 기록한다.
객체가 사용되는 만큼 레퍼런스 카운트를 1씩 증가/감소하며, 레퍼런스 카운트가 0이   되면 메모리에서 해제한다.</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#x27;Foo(&quot;{}&quot;)가 메모리에서 제거 되었습니다&#x27;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span>  <span class="token comment"># Foo(&quot;a&quot;)가 새로 생성 되었으므로 레퍼런스 카운트는 1이 된다</span>
b <span class="token operator">=</span> a  <span class="token comment"># B도 a를 참조 있으므로 Foo의 레퍼런스 카운트는 2가 된다</span>

b <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># B가 더이상 Foo(&quot;a&quot;)를 사용하지 않으므로 Foo(&quot;a&quot;)의 레퍼런스 카운트 는 1 줄어 들어 1 이 된다</span>
a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># a도 더이상 Foo(&quot;a&quot;)를 사용하지 않으므로 Foo(&quot;a&quot;)의 레퍼런스 카운트는 1 줄어 0이 되어, 해재하며 소멸자를 호출한다</span></code></pre></div><p>파이썬에서 <code>__init__</code>는 생성자, <code>__del__</code>은 소멸자이다.
위 코드를  <strong>인터프리터 모드</strong>에서 실행하면 <code>a = None</code>을 실행한 직후 <code>Foo(&quot;a&quot;)가 메모리에서 제거 되었습니다</code>라는 메시지를 볼 수 있을 것이다.
이처럼 RC를 사용하면 메모리가 필요 없어진 순간 제거 된다.</p><p>파이썬 내부에선 Reference Count 관리를 위해 <code>Py_INCREF</code>와 <code>Py_DECREF</code>를 사용한다.</p><div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Py_INCREF</span><span class="token expression"><span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">(</span>                         </span><span class="token punctuation">\</span>
    <span class="token expression">_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>PyObject <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>ob_refcnt<span class="token operator">++</span><span class="token punctuation">)</span></span></span></code></pre></div><div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Py_DECREF</span><span class="token expression"><span class="token punctuation">(</span>op<span class="token punctuation">)</span>                                   </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                                                </span><span class="token punctuation">\</span>
        <span class="token expression">PyObject <span class="token operator">*</span>_py_decref_tmp <span class="token operator">=</span> <span class="token punctuation">(</span>PyObject <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span>_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token operator">--</span><span class="token punctuation">(</span>_py_decref_tmp<span class="token punctuation">)</span><span class="token operator">-&gt;</span>ob_refcnt <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>             </span><span class="token punctuation">\</span>
            <span class="token expression"><span class="token function">_Py_CHECK_REFCNT</span><span class="token punctuation">(</span>_py_decref_tmp<span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">else</span>                                            </span><span class="token punctuation">\</span>
            <span class="token expression"><span class="token function">_Py_Dealloc</span><span class="token punctuation">(</span>_py_decref_tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>                </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span></code></pre></div><p><code>_Py_DEC_REFTOTAL</code>, <code>_Py_REF_DEBUG_COMMA</code> 처럼 디버그에서 사용하는 내용을 지우면,
<code>Py_INCREF</code>는 다음과 같으며,</p><div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token punctuation">(</span><span class="token punctuation">(</span>PyObject <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>ob_refcnt<span class="token operator">++</span><span class="token punctuation">;</span></code></pre></div><p><code>Py_DECREF</code>는 다음과 같다.</p><div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">PyObject <span class="token operator">*</span>_py_decref_tmp <span class="token operator">=</span> <span class="token punctuation">(</span>PyObject <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span>_py_decref_tmp<span class="token punctuation">)</span><span class="token operator">-&gt;</span>ob_refcnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token function">_Py_Dealloc</span><span class="token punctuation">(</span>_py_decref_tmp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><p>RC를 사용하면 프로그래머가 큰 신경을 쓰지 않아도, 필요 없다고 판단된 메모리는 그 즉시 해제할 수 있다.
개인적으로 RC는 <em>비용있는</em> 추상화 방식 중에서는 가장 우아한 방식이라고 생각한다.
아래의 문제점들만 없다면 말이다.</p><h1>문제</h1><p>메모리관리에 대해 알아본 프로그래머라면 알겠지만, 아쉽게도 RC는 만병통치약이 아니다.</p><h2>오버헤드</h2><p>첫번째로 오버헤드를 이야기 할 수 있다.
우선 <code>PyObject</code>의 <code>ob_refcnt</code> 처럼 레퍼런스 카운트를 저장할 공간이 추가적으로 필요하고,
변수를 할당할때도 추가적으로 레퍼런스 카운트를 관리해야 한다.</p><p><a href="https://blog.sn0wle0pard.io/2018/under-the-c-1/">저번 글</a>에 나온 내용을 다시 살펴보자.</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">if</span> A <span class="token operator">!=</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span></code></pre></div><p>파이썬 인터프리터에게 위 코드는 다음의 C 코드와 비슷하다.</p><div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">PyObject <span class="token operator">*</span>T <span class="token operator">=</span> Py_True<span class="token punctuation">;</span>
<span class="token function">Py_INCREF</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PyObject_RichCompareBool</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> T<span class="token punctuation">,</span> Py_NE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token function">Py_DECREF</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><p>변수 <code>A</code>와 <code>True</code>를 비교하기 위해 임시 변수 <code>T</code>를 만들었고, T는 <code>Py_True</code>값을 참조 한다.
아쉽게도 단순히 참조에서 끝나는게 아니라 필요에 따라 <code>Py_INCREF</code>와 <code>Py_DECREF</code>가 호출 된다.</p><p>오버헤드는 메모리 관리에 드는 수고를 생각하면 넘어갈 수 있을 수도 있다.
그러나 아쉽게도 해제할 수 없는 메모리도 있다.</p><h2>순환참조</h2><p>RC는 안전하지만 완전하진 않다.
모든 해제된 메모리는 필요 없는 메모리지만, 모든 필요없는 메모리가 헤제되는건 아니다.</p><p>예를 들어 다음의 코드를 보자,</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    child <span class="token operator">=</span> <span class="token boolean">None</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#x27;Foo(&quot;{}&quot;)가 메모리에서 제거 되었습니다&#x27;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span>  <span class="token comment"># Foo(&quot;a&quot;)의 ref count는 1</span>
b <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span>  <span class="token comment"># Foo(&quot;b&quot;)의 ref count는 1</span>

a<span class="token punctuation">.</span>child <span class="token operator">=</span> b  <span class="token comment"># a.child가 Foo(&quot;b&quot;)를 참조하므로 Foo(&quot;b&quot;)의 레퍼런스 카운트는 1 증가하여 2가 된다</span>
b<span class="token punctuation">.</span>child <span class="token operator">=</span> a  <span class="token comment"># b.child가 Foo(&quot;a&quot;)를 참조하므로 Foo(&quot;a&quot;)의 레퍼런스 카운트는 1 증가하여 2가 된다</span>

a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># a가 더이상 Foo(&quot;a&quot;)를 참조하지 않으므로 레퍼런스 카운트는 1 감소해서 1 이다</span>
b <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># b  가 더이상 Foo(&quot;b&quot;)를 참조하지 않으므로 레퍼런스 카운트는 1 감소해서 1 이다</span>

<span class="token comment"># Foo(&quot;a&quot;)와 Foo(&quot;b&quot;)모두 접근할 수 없지만, 레퍼런스 카운트가 남아 있으므로 해재되지 않는다</span></code></pre></div><p>위 코드를  <strong>인터프리터 모드</strong>에서 실행하면 <code>a = 0</code>이나 <code>b = 0</code>이 되면 더이상 <code>Foo(&quot;a&quot;)</code>와 <code>Foo(&quot;b&quot;)</code>에 접근 할 수 없다.
그러나 <code>a.child</code>와 <code>b.child</code>의 참조때문에 올라간 레퍼런스 카운트가 존재해 a와 b가 더이상 child에 접근 못 하더라도 해제가 불가능 하다.</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    child <span class="token operator">=</span> <span class="token boolean">None</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#x27;Foo(&quot;{}&quot;)가 메모리에서 제거 되었습니다&#x27;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span>  <span class="token comment"># Foo(&quot;a&quot;)의 ref count는 1</span>
a<span class="token punctuation">.</span>child <span class="token operator">=</span> a  <span class="token comment"># a.child가 Foo(&quot;a&quot;)를 참조하므로 Foo(&quot;a&quot;)의 레퍼런스 카운트는 1 증가하여 2가 된다</span>

a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># a가 더이상 Foo(&quot;a&quot;)를 참조하지 않으므로 레퍼런스 카운트는 1 감소해서 1 이다</span>

<span class="token comment"># Foo(&quot;a&quot;)에 접근할 수 없지만, 레퍼런스 카운트가 남아 있으므로 해재되지 않는다</span></code></pre></div><p>또 하나, 위처럼 자기 자신을 참조하는 경우도 마찬가지로 해재할 수 없다.
이 처럼 서로 참조하는 경우를 <strong>순환참조</strong>라고 하며, 레퍼런스 카운트로는 해결하기 까다롭다.</p><p>좀 더 쉬운 예를 하나 보면,</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python">x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span></code></pre></div><p>파이썬의 경우 위의 코드는 자기자신을 참조한다.</p><h1>GC</h1><p>이러한 이유로 파이썬은 RC만을 사용하지 않고, 추가적으  로 GC도 사용한다.
엄밀하게 말하면 RC도 GC의 일부지만 이 글에선 RC가 아닌 GC를 말하기로 하자.
파이썬의 GC는 <code>gcmodule.c</code>에 <a href="https://github.com/python/cpython/blob/master/Modules/gcmodule.c">정의</a> 되어 있으며,
자세한 내용은 추후에 다루도록 하겠다.</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    child <span class="token operator">=</span> <span class="token boolean">None</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#x27;Foo(&quot;{}&quot;)가 메모리에서 제거 되었습니다&#x27;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span>  <span class="token comment"># a의 ref count는 1</span>
b <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span>  <span class="token comment"># b의 ref count는 1</span>

b<span class="token punctuation">.</span>child <span class="token operator">=</span> a  <span class="token comment"># a의 ref count는 2</span>
a<span class="token punctuation">.</span>child <span class="token operator">=</span> b  <span class="token comment"># b의 ref count는 2</span>

a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># a의 ref count는 1 감소해서 1 이다 (b.child에 참조가 남아있다)</span>
b <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># b의 ref count는 1 감소해서 1 이다 (a.child에 참조가 남아있다)</span>

<span class="token keyword">import</span> gc
gc<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># GC를 직접 호출해보자 (원래는 필요한 경우 자동으로 호출 된다)</span></code></pre></div><p>위의 코드를 실행하면 <code>gc.collect()</code>가 더이상 접근할 수 없는 객체를 해재하는 것을 볼 수 있다.
특별한 설정을 하지 않는다면 파이썬은 자동으로 필요할때 gc를 호출해 RC로 해재할 수 없는 객체를 해제해 준다.</p><p>GC도 사용하므로 파이썬의 메모리 관리는 아쉽게도 RC하나만 사용하는 것에 비해 추가적인 비용이 든다.</p><p>다행인 점은 파이썬의 GC는 순환참조를 만들 가능성이 있는 컨테이너 객체를 대상으로 사용되어 모든 객체를 검사하진 않는다.</p><p>실제로, GC는 파이썬 2.0 버전부터 도입 되었으며 <a href="http://www.arctrix.com/nas/python/gc/">당시 자료</a>를 보면 이전 버전에 비해 약 4%의 성능 저하의 원인으로 생각한다고 한다.</p><p>이런 이유로 성능에 여유가  없거나, 순환참조를 피할 자신이 있다면 <code>gc.disable()</code>로 GC를 꺼도 된다.
대표적으로 <a href="https://instagram-engineering.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172">인스타그램</a>은 GC를 사용하지 않는다고 한다.</p><h2>덤: 약한참조</h2><p>다른 RC를 사용하는 언어를 사용한 분들은 들어본적이 있겠지만,
순환참조로 인한 메모리 누수를 피하는 또다른 방법은 <strong>약한참조</strong>가 있다.</p><p>쉽게 설명하면 참조는 하되, 레퍼런스 카운트는 올리지 않는 것이다.
파이썬은 <code>weakref</code>모듈을 통해 약한 참조를 사용할 수 있다.</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    child <span class="token operator">=</span> <span class="token boolean">None</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#x27;Foo(&quot;{}&quot;)가 메모리에서 제거 되었습니다&#x27;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span>  <span class="token comment"># a의 ref count는 1</span>
b <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span>  <span class="token comment"># b의 ref count는 1</span>

<span class="token keyword">import</span> weakref

<span class="token comment"># weakref를 사용했으므로 레퍼런스 카운트는 변화하지 않는다</span>
a<span class="token punctuation">.</span>child <span class="token operator">=</span> weakref<span class="token punctuation">.</span>ref<span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment"># Foo(&quot;b&quot;)의 레퍼런스 카운트는 여전히 1 이다</span>
b<span class="token punctuation">.</span>child <span class="token operator">=</span> weakref<span class="token punctuation">.</span>ref<span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment"># Foo(&quot;a&quot;)의 레퍼런스 카운트는 여전히 1 이다</span>

<span class="token comment"># 그러나 접근은 가능하다</span>
<span class="token comment"># child 자체는 weakref 객체이므로 호출을 통해 가리키는 객체를 가져올수 있다</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>

a <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># Foo(&quot;a&quot;)의 레퍼런스 카운트는 1 감소해서 0 이다</span>
<span class="token comment"># 소멸자가 호출된다</span>

<span class="token comment"># 더이상 접근이 불가능하므로 None이 반환된다</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

b <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># Foo(&quot;b&quot;)의 레퍼런스카운트는 1 감소해서 0 이다</span>
<span class="token comment"># 소멸자가 호출된다</span></code></pre></div><p><code>weakref</code>는 접근이 가능하면 해당 객체를, 해당객체가 접근 불가능 하면 <code>None</code>을 반환한다.</p><h1>RC와 GIL</h1><p>CPython은 멀티 <em>스레드</em>를 효율적으로 사용하지 못한다.
한 파이썬 프로세스는 한번에 한 스레드만 사용하며, 이를 GIL (Global interpreter lock) 이라고 부른다.</p><p>CPython에서 GIL을 제거하려는 시도는 종종 있지만, 아직까지는 GIL이 남아 있다.
그 이유중 하나가 바로 RC 때문이다.</p><p>다만 GIL 자체는 선택사항이며 원한다면 RC를 쓰고도 GIL을 제거 할 수도 있다.
잠시 다른 파이썬 구현체를 보자.</p><ul><li>Jython은 GC로 관리 하며, GIL이 없다</li><li>IronPython은 GC로 메모리 관리 하며, GIL이 없다</li><li>PyPy는 GC로 메모리 관리를 하며, GIL이 <em>있다</em></li></ul><p>PyPy가 대표적으로 GC만 사용하나, GIL이 존재한다.
그러나, PyPy는 2017년 8월 블로그글 <a href="https://morepypy.blogspot.kr/2017/08/lets-remove-global-interpreter-lock.html">Let&#x27;s remove the Global Interpreter Lock</a>를 통해 GIL을 제거할 수 있음을 알렸다.</p><p>PyPy의 블로그 글에 따르면 CPython에서 GIL을 제거하기 힘든 두가지 이유는 다음과 같다.</p><ul><li>how do we guard access to mutable data structures with locks and</li><li>what to do with reference counting that needs to be guarded.</li></ul><p>멀티스레드에서 발생하는 문제중 하나는 여러 스레드가 동시에 한 변수를 수정하려는 문제이다.
멀티스레드를 사용해본 경험이 있다면 <code>lock guard</code>와 <code>mutex</code>등을 보거나 사용해본 점이 있을 것이다.</p><p>그렇다면 스레드간 공유하는 객체는 읽기만 가능하고, 수정은 못하게 한다면 되지 않을까?
좋은 접근이지만 RC를 사용하면 쉽지많은 않은 일이다.</p><p>다시 위의 코드를 보자</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token keyword">import</span> sys


<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

a <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">read_foo</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>foo<span class="token punctuation">)</span>

read_foo<span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment"># read_foo의 매개변수 foo가 a를 참조 있으므로 Foo의 레퍼런스 카운트는 증가하였다</span>
<span class="token comment"># read_a 함수가 끝나면 레퍼런스 카운트는 다시 줄어든다</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div><p><code>getrefcount</code>는 객체의 레퍼런스 카운트 갯수를 구하는 함수다.
우리가 생각한 레퍼런스 카운트 횟수보다 좀 더 많을 텐데 <a href="https://docs.python.org/3/library/sys.html#sys.getrefcount">문서</a>의 내용에 따르면, <code>getrefcount</code>함수를 실행하기 위해 매개변수로 참조 카운트가 증가 하여 그렇다.</p><p>내용으로 돌아가면 <code>read_foo</code>는 <code>a</code>의 내용을 읽기만 하고 수정하진 않았지만, 매개변수등 참조가 일어 날때마나 <code>obj_refcnt</code>는 증/감 한다.
여러 스레드가 동시에 참조를 만든다면 동시수정과 다름 없는 상태가 된다.</p><p>추가로 RC를 사용하고도 이 문제를 피할 방법 자체는 있다.
예를 들어 <code>std::atomic</code>이 있다(<a href="http://www.cplusplus.com/reference/atomic/atomic/">C++ 문서</a>).
atomic은 DB의 Atomic 성질 처럼 순서대로 진행하는걸 보장하는데,
즉 두 스레드가 거의 동시에 레퍼런스 카운트를 변화 하려고 하면, 먼저 요청한 스레드의 요청대로 한 obj_refcnt를 변화시키고, 그 다음 스레드 요청을 처리한다.</p><p>대표적인 예로 Rust의 <code>Rc</code>와 <code>ARc</code>가 있다.
Rust 자체는 무비용 추상화로 메모리를 관리하지만, 원한다면 RC로 관리되는 객체를 만들 수 있다.
이  경우 싱글 스레드면 <code>Rc</code>를 멀티 스레드면 <code>ARc</code>를 사용하면 되는데, <code>ARc</code>는 레퍼런스 카운트가 atomic 하게 동작한다.</p><p>Atomic을 보장하는 것은 추가적인 오버헤드가 있다는 이야기다.
실제로 ARc <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">문서</a>를 보면,
원자성 보장은 일반 메모리 접근보다 비용이 많이 들고, 싱글스레드라면 비용을 줄이기 위에 <code>Rc</code>를 쓸 수 있다고 언급하고 있다.</p><p>현재 파이썬의 대부분은 싱글 스레드 환경이며, 멀티스레드를 위해 싱글스레드 저하를 선택할 것인가는 논쟁의 여지가 있다.
현재로는 파이썬 커뮤니티는 멀티스레드 사용을 위해 싱글스레드 성능이 저하 되는 해결을 받아 들이고 싶어 하지 않는다.
<a href="https://wiki.python.org/moin/GlobalInterpreterLock?action=show&amp;redirect=GIL">파이썬 위키</a>의 GIL 항목을 인용 하면</p><blockquote><p>The BDFL has said he will reject any proposal in this direction that slows down single-threaded programs.</p></blockquote><p>BDFL은 파이썬 창시자 귀도 반 로썸을 말한다. 위키백과의 설명을 인용한다.</p><blockquote><p>자비로운 종신독재자(BDFL, Benevolent Dictator for Life)란 소수의 오픈 소스 소프트웨어 개발 리더에게 부여되는 칭호이다. 주로 커뮤니티 내에서 논쟁이 있을 때 최종적으로 결론을 내려줄 수 있는, 프로젝트 창시자인 경우가 많다. 이 표현은 1995년에 파이썬의 창시자 귀도 반 로섬을 가리키는 호칭으로 처음 사용되었다.</p></blockquote><p>개인적으로도 멀티스레드를 위해 싱글스레드 성능저하가 심각하다면 받아 들이고 싶지 않다.</p><p>실제로 파이썬에 atomic 레퍼런스 카운트를 사용하게되면 <a href="https://greek0.net/blog/2015/05/23/python_atomic_refcounting_slowdown/">약 23%의 성능저하</a>를   보인다고 한다.</p><p>공유하는 객체만 원자성 보장을 하면 어떨까?
멀티 스레드를 사용하는 코딩을 해도 스레드간 공유될 객체가 몇 안될 것 같다고 생각한다면,
파이썬 콘솔을 켜서 다음 코드를 실행해 보길 권한다.</p><div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> sys
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
<span class="token number">2296</span></code></pre></div><p>글을 시작하며 언급한것 처럼 파이썬의 모든건 객체다.
단순한 값으로 생각할 수 있는 <code>None</code>도 하나의 객체며 여러곳에서 공유하고 있다.
왜 어려운 문제인지 짐작 할 수 있을 것이다.</p></article><div class="c-jEDjTQ"><img src="/images/profile.png" draggable="false" alt="" class="c-dvRuTq"/><div class="c-bZcNek"><h2 class="c-jwOSHF">이한</h2><p class="c-dMmbPO">Coding a Better World Together</p><a role="menuitem" href="https://hanlee.io" class="c-euCchw">About</a><a role="menuitem" href="https://github.com/hahnlee" class="c-euCchw">GitHub</a><a role="menuitem" href="/rss.xml" class="c-euCchw">RSS</a></div></div></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-111601591-4', 'auto', {});
      
      
      
      
      
      }</script><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/2018/under-the-c-2";window.___webpackCompilationHash="88136e8a4bae610b2757";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-38856857010c707155ba.js"],"app":["/app-5790141a17fa8fba8d29.js"],"component---src-containers-post-tsx":["/component---src-containers-post-tsx-04e02e434c586a440b06.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-dee006d33227048c692c.js"]};/*]]>*/</script><script src="/polyfill-38856857010c707155ba.js" nomodule=""></script><script src="/app-5790141a17fa8fba8d29.js" async=""></script><script src="/framework-043a7c4ea56bed9a642b.js" async=""></script><script src="/webpack-runtime-3f5db17dec4efafe5e36.js" async=""></script></body></html>